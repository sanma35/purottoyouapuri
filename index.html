<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>プロットメーカー PRO</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #app {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 90%;
            max-width: 1000px; /* 少し広めに */
            margin-bottom: 30px;
            display: flex; /* Flexboxでレイアウト */
            gap: 20px;
        }
        #sidebar {
            width: 250px;
            padding-right: 20px;
            border-right: 1px solid #eee;
            flex-shrink: 0; /* 縮まない */
        }
        #main-content {
            flex-grow: 1; /* 残りのスペースを埋める */
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
            font-size: 2.2em;
        }
        h2 {
            color: #34495e;
            margin-top: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
            font-size: 1.6em;
        }
        h3 {
             color: #4a637d;
             margin-top: 15px;
             margin-bottom: 10px;
             font-size: 1.3em;
        }
        .section-title { /* 既存のsection-titleはh2, h3などに置き換え */
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
            font-size: 1.5em;
        }
        .input-group {
            margin-bottom: 18px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        .input-group input[type="text"],
        .input-group input[type="number"],
        .input-group textarea,
        .input-group select {
            width: calc(100% - 20px);
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            box-sizing: border-box;
            background-color: #fafafa;
        }
        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap; /* ボタンの折り返し */
        }
        button {
            background-color: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease, transform 0.1s ease;
            white-space: nowrap; /* ボタン内のテキスト改行防止 */
        }
        button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        button.edit-btn {
            background-color: #f39c12; /* 黄色っぽいオレンジ */
            padding: 6px 12px; /* リスト内ボタンのサイズ */
            font-size: 0.8em;
            margin-left: 8px;
        }
        button.edit-btn:hover {
            background-color: #e67e22;
        }

        #plot-output { /* 使用しないかもしれませんが残しておきます */
            background-color: #ecf0f1;
            border: 1px dashed #bdc3c7;
            padding: 25px;
            min-height: 200px;
            margin-top: 30px;
            border-radius: 8px;
            font-size: 1.1em;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .list-container {
            list-style: none;
            padding: 0;
            max-height: 300px; /* スクロール可能にする */
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: #fcfcfc;
        }
        .list-container li {
            background-color: #f9f9f9;
            border-bottom: 1px solid #eee;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .list-container li:last-child {
            border-bottom: none;
        }
        .list-container li:hover {
            background-color: #eaf3f9;
        }
        .list-container li.selected {
            background-color: #dbe9f5;
            font-weight: bold;
            color: #2c3e50;
        }
        .list-container li span {
            flex-grow: 1;
            margin-right: 15px;
        }
        .list-container li .list-item-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* ボタン間のスペース */
        }
        .list-container li button {
            padding: 6px 12px;
            font-size: 0.8em;
            margin-left: 8px; /* 従来のmargin-left */
            box-shadow: none; /* リスト内ボタンの影をなくす */
        }

        /* Drag and Drop styles */
        .list-container li[draggable="true"] {
            cursor: grab;
        }
        .list-container li[draggable="true"]:active {
            cursor: grabbing;
        }
        .list-container li.dragging {
            opacity: 0.5;
            border: 2px dashed #3498db;
            background-color: #e0f0fb;
        }
        .list-container li.drag-over {
            border-top: 2px solid #3498db;
            /* ドラッグオーバー時の線の色と太さ */
        }
        /* drag-over-bottom はドラッグを下に挿入する際に使用 */
        .list-container li.drag-over-bottom {
            border-bottom: 2px solid #3498db;
        }

        .plot-type-options {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .plot-type-options label {
            background-color: #e0e0e0;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .plot-type-options label:hover {
            background-color: #d0d0d0;
        }
        .plot-type-options input[type="radio"] {
            display: none;
        }
        .plot-type-options input[type="radio"]:checked + label {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }

        /* モーダルダイアログ */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }
        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: #000;
            text-decoration: none;
        }
        #overallSummaryTextarea, #charDetailSummaryTextarea {
            width: calc(100% - 20px);
            min-height: 200px;
            margin-bottom: 15px;
        }
        #charDetailInputs label, #charDetailInputs input {
            margin-bottom: 10px;
        }
        #charDetailInputs input {
            width: calc(100% - 10px);
        }

        /* 描画・画像・テーブル関連のスタイル */
        #drawingCanvas, #timelineCanvas {
            border: 1px solid #bdc3c7;
            background-color: white;
            display: block;
            margin-top: 15px;
            border-radius: 5px;
        }
        #imagePreviewElement img {
            max-width: 100%;
            height: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            display: block;
            margin-top: 15px;
        }
        #tablePreviewElement table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        #tablePreviewElement th, #tablePreviewElement td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
            word-wrap: break-word; /* 長い単語の折り返し */
        }
        #tablePreviewElement td[contenteditable="true"]:focus {
            outline: 2px solid #3498db;
        }
        #tablePreviewElement th {
            background-color: #e9ecef;
        }

        /* スクロールバーのスタイル（任意） */
        .list-container::-webkit-scrollbar,
        body::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .list-container::-webkit-scrollbar-thumb,
        body::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 4px;
        }
        .list-container::-webkit-scrollbar-track,
        body::-webkit-scrollbar-track {
            background-color: #f1f1f1;
        }

        /* キャラクター選択ドロップダウン */
        #characterSelectForScene {
            width: calc(100% - 20px);
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            box-sizing: border-box;
            background-color: #fafafa;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h1>プロットメーカー PRO</h1>
            <div class="section">
                <h2>作品リスト</h2>
                <ul id="project-list" class="list-container">
                    </ul>
                <div class="button-group">
                    <button id="addProjectButton">新しい作品</button>
                    <button id="deleteProjectButton" class="danger secondary">作品を削除</button>
                </div>
            </div>

            <div class="section" id="overall-summary-section" style="display:none;">
                <h2>作品概要</h2>
                <div class="button-group">
                    <button id="openOverallSummaryModal">概要メモを開く</button>
                </div>
            </div>

            <div class="section" id="character-list-section" style="display:none;">
                <h2>キャラクターリスト</h2>
                <ul id="character-list" class="list-container">
                    </ul>
                <div class="button-group">
                    <button id="addCharacterButton">新しいキャラクター</button>
                    <button id="deleteCharacterButton" class="danger secondary">キャラクターを削除</button>
                </div>
            </div>

            <div class="section" id="sequence-list-section" style="display:none;">
                <h2>シークエンスリスト</h2>
                <ul id="sequence-list" class="list-container">
                    </ul>
                <div class="button-group">
                    <button id="addSequenceButton">新しいシークエンス</button>
                    <button id="deleteSequenceButton" class="danger secondary">シークエンスを削除</button>
                </div>
            </div>
        </div>

        <div id="main-content">
            <h2 id="current-project-title">作品を選択してください</h2>
            <h3 id="current-sequence-title" style="display:none;"></h3>

            <div class="section" id="scene-input-section" style="display:none;">
                <h3>シーン入力</h3>
                <div class="plot-type-options">
                    <input type="radio" id="typeTimeline" name="plotType" value="timeline" checked>
                    <label for="typeTimeline">時系列プロット</label>

                    <input type="radio" id="typeCharacter" name="plotType" value="character">
                    <label for="typeCharacter">キャラクタープロット</label>

                    <input type="radio" id="typeStory" name="plotType" value="story">
                    <label for="typeStory">ストーリープロット</label>
                </div>

                <div id="timelinePlotInputs">
                    <div class="input-group">
                        <label for="date">日付/時期:</label>
                        <input type="text" id="date" placeholder="例: 2023/01/15, 紀元前500年, 夏">
                    </div>
                    <div class="input-group">
                        <label for="event">出来事/内容:</label>
                        <textarea id="event" placeholder="例: 主人公が新しいスキルを習得する"></textarea>
                    </div>
                </div>

                <div id="characterPlotInputs" style="display: none;">
                    <div class="input-group">
                        <label for="characterSelectForScene">既存キャラクターを選択:</label>
                        <select id="characterSelectForScene">
                            <option value="">-- 新しいキャラクター --</option>
                            </select>
                    </div>
                    <div class="input-group">
                        <label for="charName">キャラクター名 (新規の場合):</label>
                        <input type="text" id="charName" placeholder="例: エルザ">
                    </div>
                    <div class="input-group">
                        <label for="charTrait">特徴/性格:</label>
                        <textarea id="charTrait" placeholder="例: 冷静沈着、魔力が高い"></textarea>
                    </div>
                    <div class="input-group">
                        <label for="charRole">役割:</label>
                        <input type="text" id="charRole" placeholder="例: 主人公、敵役、サポート">
                    </div>
                </div>

                <div id="storyPlotInputs" style="display: none;">
                    <div class="input-group">
                        <label for="storyChapter">章/シーン:</label>
                        <input type="text" id="storyChapter" placeholder="例: 第1章: 出会い、シーン3: 訓練">
                    </div>
                    <div class="input-group">
                        <label for="storySummary">概要:</label>
                        <textarea id="storySummary" placeholder="例: 主人公とヒロインが初めて出会い、互いの目標を知る"></textarea>
                    </div>
                    <div class="input-group">
                        <label for="storyConflict">葛藤/解決:</label>
                        <textarea id="storyConflict" placeholder="例: 内なる葛藤、敵との対決、新たな友情"></textarea>
                    </div>
                </div>

                <div class="button-group">
                    <button id="addSceneButton">シーンを追加</button>
                    <button id="clearSceneInputs" class="secondary">入力クリア</button>
                </div>
            </div>

            <div class="section" id="scene-list-section" style="display:none;">
                <h3>シーンリスト</h3>
                <ul id="scene-list" class="list-container">
                    </ul>
                <div class="button-group">
                    <button id="deleteSceneButton" class="danger secondary">シーンを削除</button>
                </div>
            </div>

            <div class="section" id="scene-details-section" style="display:none;">
                <h3>選択中のシーン詳細</h3>
                <div id="selected-scene-content">
                    </div>

                <div class="section-title">タイムライン描画</div>
                <div class="button-group">
                    <button id="timelineDisplayMode">タイムライン表示モード切り替え</button>
                </div>
                <canvas id="timelineCanvas" width="800" height="200"></canvas>

                <div class="section-title">自由描画</div>
                <div class="button-group">
                    <button id="drawingModeButton">描画モード切り替え</button>
                    <label for="lineThickness">太さ:</label>
                    <input type="range" id="lineThickness" min="1" max="20" value="5">
                    <label for="lineColor">色:</label>
                    <input type="color" id="lineColor" value="#000000">
                    <button id="clearDrawingButton" class="secondary">クリア</button>
                </div>
                <canvas id="drawingCanvas" width="800" height="400"></canvas>

                <div class="section-title">画像</div>
                <div class="input-group">
                    <label for="imageUpload">画像をアップロード:</label>
                    <input type="file" id="imageUpload" accept="image/*">
                </div>
                <div id="imagePreviewElement"></div>

                <div class="section-title">テーブル</div>
                <div class="input-group">
                    <label>テーブルサイズ:</label>
                    <input type="number" id="tableRowsInput" value="3" min="1" max="100" style="width: 80px;"> 行
                    <input type="number" id="tableColsInput" value="3" min="1" max="100" style="width: 80px; margin-left: 10px;"> 列
                </div>
                <div class="button-group">
                    <button id="createTableButton">テーブル作成</button>
                </div>
                <div id="tablePreviewElement"></div>
            </div>
        </div>
    </div>

    <div id="overallSummaryModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>作品全体概要</h2>
            <textarea id="overallSummaryTextarea" placeholder="作品全体のあらすじや設定などをここに記述してください。"></textarea>
            <div class="button-group">
                <button id="saveOverallSummaryButton">保存</button>
            </div>
        </div>
    </div>

    <div id="characterDetailModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>キャラクター詳細</h2>
            <div id="charDetailInputs">
                <div class="input-group">
                    <label for="charDetailName">キャラクター名:</label>
                    <input type="text" id="charDetailName" placeholder="例: エルザ">
                </div>
                <div class="input-group">
                    <label for="charDetailTrait">特徴/性格:</label>
                    <input type="text" id="charDetailTrait" placeholder="例: 冷静沈着、魔力が高い">
                </div>
                <div class="input-group">
                    <label for="charDetailRole">役割:</label>
                    <input type="text" id="charDetailRole" placeholder="例: 主人公、敵役、サポート">
                </div>
                <div class="input-group">
                    <label for="charDetailSummaryTextarea">詳細メモ:</label>
                    <textarea id="charDetailSummaryTextarea" placeholder="キャラクターの背景、生い立ち、能力、人間関係など、詳細な情報を記述してください。"></textarea>
                </div>
            </div>
            <div class="button-group">
                <button id="saveCharacterDetailButton">保存</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI要素の取得 ---
            const projectList = document.getElementById('project-list');
            const addProjectButton = document.getElementById('addProjectButton');
            const deleteProjectButton = document.getElementById('deleteProjectButton');
            const overallSummarySection = document.getElementById('overall-summary-section');
            const openOverallSummaryModalButton = document.getElementById('openOverallSummaryModal');
            const overallSummaryModal = document.getElementById('overallSummaryModal');
            const closeOverallSummaryModalButton = overallSummaryModal.querySelector('.close-button');
            const overallSummaryTextarea = document.getElementById('overallSummaryTextarea');
            const saveOverallSummaryButton = document.getElementById('saveOverallSummaryButton');

            const characterListSection = document.getElementById('character-list-section'); // キャラクターリストセクション
            const characterList = document.getElementById('character-list'); // キャラクターリスト
            const addCharacterButton = document.getElementById('addCharacterButton'); // キャラクター追加ボタン
            const deleteCharacterButton = document.getElementById('deleteCharacterButton'); // キャラクター削除ボタン
            const characterDetailModal = document.getElementById('characterDetailModal'); // キャラクター詳細モーダル
            const closeCharacterDetailModalButton = characterDetailModal.querySelector('.close-button');
            const charDetailNameInput = document.getElementById('charDetailName'); // 詳細モーダル内の名前入力
            const charDetailTraitInput = document.getElementById('charDetailTrait'); // 詳細モーダル内の特徴入力
            const charDetailRoleInput = document.getElementById('charDetailRole'); // 詳細モーダル内の役割入力
            const charDetailSummaryTextarea = document.getElementById('charDetailSummaryTextarea'); // 詳細モーダル内のメモ入力
            const saveCharacterDetailButton = document.getElementById('saveCharacterDetailButton'); // 詳細モーダル内の保存ボタン

            const sequenceListSection = document.getElementById('sequence-list-section');
            const sequenceList = document.getElementById('sequence-list');
            const addSequenceButton = document.getElementById('addSequenceButton');
            const deleteSequenceButton = document.getElementById('deleteSequenceButton');

            const sceneInputSection = document.getElementById('scene-input-section');
            const sceneListSection = document.getElementById('scene-list-section');
            const sceneDetailsSection = document.getElementById('scene-details-section');
            const sceneList = document.getElementById('scene-list');
            const addSceneButton = document.getElementById('addSceneButton');
            const deleteSceneButton = document.getElementById('deleteSceneButton');
            const selectedSceneContent = document.getElementById('selected-scene-content');

            const currentProjectTitle = document.getElementById('current-project-title');
            const currentSequenceTitle = document.getElementById('current-sequence-title');

            // --- 既存のプロット入力UI要素 ---
            const radioButtons = document.querySelectorAll('input[name="plotType"]');
            const timelineInputs = document.getElementById('timelinePlotInputs');
            const characterInputs = document.getElementById('characterPlotInputs'); // シーン追加時のキャラクター入力
            const storyInputs = document.getElementById('storyPlotInputs');

            const dateInput = document.getElementById('date');
            const eventInput = document.getElementById('event');
            const charNameInput = document.getElementById('charName'); // シーン追加時用
            const charTraitInput = document.getElementById('charTrait'); // シーン追加時用
            const charRoleInput = document.getElementById('charRole'); // シーン追加時用
            const characterSelectForScene = document.getElementById('characterSelectForScene'); // シーン追加時の既存キャラクター選択
            const storyChapterInput = document.getElementById('storyChapter');
            const storySummaryInput = document.getElementById('storySummary');
            const storyConflictInput = document.getElementById('storyConflict');
            const clearSceneInputsButton = document.getElementById('clearSceneInputs');

            // --- 描画・画像・テーブルUI要素 ---
            const timelineCanvas = document.getElementById('timelineCanvas');
            const timelineContext = timelineCanvas.getContext('2d');
            const timelineDisplayModeButton = document.getElementById('timelineDisplayMode');

            const drawingCanvas = document.getElementById('drawingCanvas');
            const drawingContext = drawingCanvas.getContext('2d');
            const drawingModeButton = document.getElementById('drawingModeButton');
            const lineThicknessInput = document.getElementById('lineThickness');
            const lineColorInput = document.getElementById('lineColor');
            const clearDrawingButton = document.getElementById('clearDrawingButton');

            const imageUploadInput = document.getElementById('imageUpload');
            const imagePreviewElement = document.getElementById('imagePreviewElement');

            const tableRowsInput = document.getElementById('tableRowsInput');
            const tableColsInput = document.getElementById('tableColsInput');
            const createTableButton = document.getElementById('createTableButton');
            const tablePreviewElement = document.getElementById('tablePreviewElement');

            // --- データモデル ---
            let projects = []; // 全ての作品データを保持
            let currentProjectId = null;
            let currentSequenceId = null;
            let currentSceneId = null; // 選択中のシーンID
            let currentCharacterId = null; // 選択中のキャラクターID (新しい機能)

            // 描画・画像・テーブルの一時データ
            let isDrawingMode = false;
            let drawingPath = [];
            let currentDrawingData = []; // 現在のシーンの描画パス
            let currentImageData = null; // 現在のシーンの画像
            let currentTableData = null; // 現在のシーンのテーブル

            // 描画関連
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            // 自動保存用タイマー
            let autoSaveTimer;
            const AUTO_SAVE_DELAY = 1000; // 自動保存の遅延時間 (ミリ秒)

            // ドラッグ＆ドロップ関連
            let draggedItem = null; // ドラッグ中の要素を保持
            let dragType = null; // ドラッグ中の要素のタイプ (project, character, sequence, scene)

            // --- データ管理関数 ---
            function generateId() {
                return '_' + Math.random().toString(36).substr(2, 9);
            }

            // autoSaveFlag: trueの場合、アラートを表示しない
            function saveProjects(autoSaveFlag = false) {
                localStorage.setItem('plotMakerProjects', JSON.stringify(projects));
                if (!autoSaveFlag) {
                    console.log('Projects saved:', projects); // デバッグ用
                }
            }

            function loadProjects() {
                const savedProjects = localStorage.getItem('plotMakerProjects');
                projects = savedProjects ? JSON.parse(savedProjects) : [];
                // データの初期化チェック（過去のバージョンからの互換性のため）
                projects.forEach(project => {
                    if (!project.characters) project.characters = [];
                    if (!project.sequences) project.sequences = [];
                    project.sequences.forEach(seq => {
                        if (!seq.scenes) seq.scenes = [];
                    });
                });
                console.log('Projects loaded:', projects); // デバッグ用
                renderProjectList();
            }

            // --- UIレンダリング関数 ---
            function renderProjectList() {
                projectList.innerHTML = '';
                if (projects.length === 0) {
                    projectList.innerHTML = '<li>作品がありません。「新しい作品」を作成してください。</li>';
                    return;
                }
                projects.forEach(project => {
                    const listItem = document.createElement('li');
                    listItem.dataset.id = project.id;
                    listItem.dataset.type = 'project'; // 追加
                    listItem.draggable = true; // 追加
                    if (project.id === currentProjectId) {
                        listItem.classList.add('selected');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = project.name;
                    nameSpan.addEventListener('click', () => selectProject(project.id));
                    listItem.appendChild(nameSpan);

                    const controlsDiv = document.createElement('div');
                    controlsDiv.classList.add('list-item-controls');

                    const editButton = document.createElement('button');
                    editButton.textContent = '編集';
                    editButton.classList.add('edit-btn');
                    editButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // liのクリックイベントが発火しないようにする
                        editProjectName(project.id);
                    });
                    controlsDiv.appendChild(editButton);

                    listItem.appendChild(controlsDiv);
                    projectList.appendChild(listItem);
                });
                addDragAndDropListeners(projectList); // 追加
            }

            function renderCharacterList() {
                characterList.innerHTML = '';
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (!currentProject || !currentProject.characters || currentProject.characters.length === 0) {
                    characterList.innerHTML = '<li>キャラクターが登録されていません。</li>';
                    return;
                }
                currentProject.characters.forEach(char => {
                    const listItem = document.createElement('li');
                    listItem.dataset.id = char.id;
                    listItem.dataset.type = 'character'; // 追加
                    listItem.draggable = true; // 追加
                    if (char.id === currentCharacterId) {
                        listItem.classList.add('selected');
                    }
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = char.name;
                    nameSpan.addEventListener('click', (e) => {
                        e.stopPropagation(); // li要素へのクリックがキャラクター選択イベントをトリガーする
                        selectCharacter(char.id);
                    });
                    listItem.appendChild(nameSpan);

                    characterList.appendChild(listItem);
                });
                addDragAndDropListeners(characterList); // 追加
            }

            function renderSequenceList() {
                sequenceList.innerHTML = '';
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (!currentProject || currentProject.sequences.length === 0) {
                    sequenceList.innerHTML = '<li>シークエンスがありません。「新しいシークエンス」を作成してください。</li>';
                    return;
                }
                currentProject.sequences.forEach(seq => {
                    const listItem = document.createElement('li');
                    listItem.dataset.id = seq.id;
                    listItem.dataset.type = 'sequence'; // 追加
                    listItem.draggable = true; // 追加
                    if (seq.id === currentSequenceId) {
                        listItem.classList.add('selected');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = seq.name;
                    nameSpan.addEventListener('click', () => selectSequence(seq.id));
                    listItem.appendChild(nameSpan);

                    const controlsDiv = document.createElement('div');
                    controlsDiv.classList.add('list-item-controls');

                    const editButton = document.createElement('button');
                    editButton.textContent = '編集';
                    editButton.classList.add('edit-btn');
                    editButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // liのクリックイベントが発火しないようにする
                        editSequenceName(seq.id);
                    });
                    controlsDiv.appendChild(editButton);

                    listItem.appendChild(controlsDiv);
                    sequenceList.appendChild(listItem);
                });
                addDragAndDropListeners(sequenceList); // 追加
            }

            function renderSceneList() {
                sceneList.innerHTML = '';
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject ? currentProject.sequences.find(s => s.id === currentSequenceId) : null;

                if (!currentSequence || currentSequence.scenes.length === 0) {
                    sceneList.innerHTML = '<li>シーンがありません。「シーンを追加」してください。</li>';
                    return;
                }
                currentSequence.scenes.forEach(scene => {
                    const listItem = document.createElement('li');
                    listItem.dataset.id = scene.id;
                    listItem.dataset.type = 'scene'; // 追加
                    listItem.draggable = true; // 追加
                    if (scene.id === currentSceneId) {
                        listItem.classList.add('selected');
                    }
                    let displayTitle = '';
                    if (scene.type === 'timeline') {
                        displayTitle = `[${scene.data.date || '日付なし'}] ${scene.data.event?.substring(0, 30) || '出来事なし'}...`;
                    } else if (scene.type === 'character') {
                        // 作品のキャラクターリストから名前を取得、見つからなければシーンのcharNameを使用
                        const charName = currentProject?.characters.find(c => c.id === scene.data.charId)?.name || scene.data.charName;
                        displayTitle = `👤 ${charName || '不明'} (${scene.data.charRole || '役割不明'})`;
                    } else if (scene.type === 'story') {
                        displayTitle = `📖 ${scene.data.storyChapter || '章なし'}: ${scene.data.storySummary?.substring(0, 30) || '概要なし'}...`;
                    }
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = displayTitle;
                    nameSpan.addEventListener('click', () => selectScene(scene.id));
                    listItem.appendChild(nameSpan);

                    sceneList.appendChild(listItem);
                });
                addDragAndDropListeners(sceneList); // 追加
            }

            function renderSelectedSceneDetails() {
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject ? currentProject.sequences.find(s => s.id === currentSequenceId) : null;
                const currentScene = currentSequence ? currentSequence.scenes.find(sc => sc.id === currentSceneId) : null;

                selectedSceneContent.innerHTML = '';
                if (!currentScene) {
                    selectedSceneContent.textContent = 'シーンが選択されていません。';
                    // 描画・画像・テーブルエリアもクリア
                    clearDrawingCanvas();
                    imagePreviewElement.innerHTML = '';
                    tablePreviewElement.innerHTML = '';
                    currentDrawingData = [];
                    currentImageData = null;
                    currentTableData = null;
                    return;
                }

                let detailHTML = '';
                if (currentScene.type === 'timeline') {
                    detailHTML = `
                        <div class="input-group">
                            <label for="editDate">日付/時期:</label>
                            <input type="text" id="editDate" value="${currentScene.data.date || ''}" placeholder="例: 2023/01/15, 紀元前500年, 夏">
                        </div>
                        <div class="input-group">
                            <label for="editEvent">出来事/内容:</label>
                            <textarea id="editEvent" placeholder="例: 主人公が新しいスキルを習得する">${currentScene.data.event || ''}</textarea>
                        </div>
                        <div class="button-group"><button id="saveSceneDetailsButton">シーン内容を保存</button></div>
                    `;
                } else if (currentScene.type === 'character') {
                    // キャラクターの元の名前（ID紐付けされている場合）
                    const originalCharName = currentProject?.characters.find(c => c.id === currentScene.data.charId)?.name || currentScene.data.charName;
                    
                    detailHTML = `
                        <div class="input-group">
                            <label for="editCharName">キャラクター名:</label>
                            <input type="text" id="editCharName" value="${originalCharName || ''}" placeholder="例: エルザ" ${currentScene.data.charId ? 'disabled' : ''}>
                        </div>
                        <div class="input-group">
                            <label for="editCharTrait">特徴/性格:</label>
                            <textarea id="editCharTrait" placeholder="例: 冷静沈着、魔力が高い">${currentScene.data.charTrait || ''}</textarea>
                        </div>
                        <div class="input-group">
                            <label for="editCharRole">役割:</label>
                            <input type="text" id="editCharRole" value="${currentScene.data.charRole || ''}" placeholder="例: 主人公、敵役、サポート">
                        </div>
                        <div class="button-group">
                            <button id="saveSceneDetailsButton">シーン内容を保存</button>
                            ${currentScene.data.charId ? `<button id="openCharacterDetailFromSceneButton" data-char-id="${currentScene.data.charId}" class="secondary">キャラクター詳細を開く</button>` : ''}
                        </div>
                    `;
                } else if (currentScene.type === 'story') {
                    detailHTML = `
                        <div class="input-group">
                            <label for="editStoryChapter">章/シーン:</label>
                            <input type="text" id="editStoryChapter" value="${currentScene.data.storyChapter || ''}" placeholder="例: 第1章: 出会い、シーン3: 訓練">
                        </div>
                        <div class="input-group">
                            <label for="editStorySummary">概要:</label>
                            <textarea id="editStorySummary" placeholder="例: 主人公とヒロインが初めて出会い、互いの目標を知る">${currentScene.data.storySummary || ''}</textarea>
                        </div>
                        <div class="input-group">
                            <label for="editStoryConflict">葛藤/解決:</label>
                            <textarea id="editStoryConflict" placeholder="例: 内なる葛藤、敵との対決、新たな友情">${currentScene.data.storyConflict || ''}</textarea>
                        </div>
                        <div class="button-group"><button id="saveSceneDetailsButton">シーン内容を保存</button></div>
                    `;
                }
                selectedSceneContent.innerHTML = detailHTML;

                // シーン内容保存ボタンのイベントリスナー
                const saveSceneDetailsButton = document.getElementById('saveSceneDetailsButton');
                if (saveSceneDetailsButton) {
                    saveSceneDetailsButton.addEventListener('click', () => {
                        if (currentScene) {
                            if (currentScene.type === 'timeline') {
                                currentScene.data.date = document.getElementById('editDate').value.trim();
                                currentScene.data.event = document.getElementById('editEvent').value.trim();
                            } else if (currentScene.type === 'character') {
                                // 既存キャラに紐付いている場合は名前は編集不可、特徴と役割のみ
                                if (!currentScene.data.charId) { // 新規作成したキャラクターの場合のみ名前も編集可能
                                    currentScene.data.charName = document.getElementById('editCharName').value.trim();
                                }
                                currentScene.data.charTrait = document.getElementById('editCharTrait').value.trim();
                                currentScene.data.charRole = document.getElementById('editCharRole').value.trim();
                                // もしcharIdがあるなら、元のキャラクター情報も更新する
                                if (currentScene.data.charId) {
                                    const charToUpdate = currentProject?.characters.find(c => c.id === currentScene.data.charId);
                                    if (charToUpdate) {
                                        // charToUpdate.name = currentScene.data.charName; // シーンで紐付いた既存キャラの名前は変更しない
                                        charToUpdate.traits = currentScene.data.charTrait;
                                        charToUpdate.role = currentScene.data.charRole;
                                    }
                                }
                            } else if (currentScene.type === 'story') {
                                currentScene.data.storyChapter = document.getElementById('editStoryChapter').value.trim();
                                currentScene.data.storySummary = document.getElementById('editStorySummary').value.trim();
                                currentScene.data.storyConflict = document.getElementById('editStoryConflict').value.trim();
                            }
                            saveProjects();
                            alert('シーン内容を保存しました！');
                            renderSceneList(); // シーンリストの表示も更新（名前が変更された場合など）
                            renderSelectedSceneDetails(); // 詳細を再レンダリングして最新の状態を反映
                        }
                    });
                }

                // 自動保存のイベントリスナーを再設定 (inputフィールドが動的に生成されるため)
                const editDateInput = document.getElementById('editDate');
                const editEventTextarea = document.getElementById('editEvent');
                const editCharNameInput = document.getElementById('editCharName');
                const editCharTraitTextarea = document.getElementById('editCharTrait');
                const editCharRoleInput = document.getElementById('editCharRole');
                const editStoryChapterInput = document.getElementById('editStoryChapter');
                const editStorySummaryTextarea = document.getElementById('editStorySummary');
                const editStoryConflictTextarea = document.getElementById('editStoryConflict');

                // 各input要素に自動保存イベントリスナーを設定
                if (editDateInput) editDateInput.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editEventTextarea) editEventTextarea.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editCharNameInput) editCharNameInput.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editCharTraitTextarea) editCharTraitTextarea.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editCharRoleInput) editCharRoleInput.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editStoryChapterInput) editStoryChapterInput.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editStorySummaryTextarea) editStorySummaryTextarea.addEventListener('input', scheduleAutoSaveSceneDetails);
                if (editStoryConflictTextarea) editStoryConflictTextarea.addEventListener('input', scheduleAutoSaveSceneDetails);


                // 描画データ読み込みと描画
                currentDrawingData = currentScene.drawings || [];
                drawAllDrawings();

                // 画像データ読み込みと表示
                currentImageData = currentScene.image || null;
                if (currentImageData && currentImageData.dataUrl) {
                    const img = document.createElement('img');
                    img.src = currentImageData.dataUrl;
                    imagePreviewElement.innerHTML = '';
                    imagePreviewElement.appendChild(img);
                } else {
                    imagePreviewElement.innerHTML = '';
                }

                // テーブルデータ読み込みと表示
                currentTableData = currentScene.table || null;
                if (currentTableData) {
                    renderTablePreview(currentTableData);
                } else {
                    tablePreviewElement.innerHTML = '';
                }

                // シーン内の「キャラクター詳細を開く」ボタンのイベントリスナー
                const openCharDetailBtn = document.getElementById('openCharacterDetailFromSceneButton');
                if (openCharDetailBtn) {
                    openCharDetailBtn.addEventListener('click', (e) => {
                        const charId = e.target.dataset.charId;
                        if (charId) {
                            selectCharacter(charId); // キャラクターリストで選択状態にして、詳細モーダルを開く
                        }
                    });
                }
            }


            // --- 選択・表示制御 ---
            function selectProject(projectId) {
                currentProjectId = projectId;
                currentSequenceId = null; // 作品が変わったらシークエンス選択をリセット
                currentSceneId = null; // シーン選択もリセット
                currentCharacterId = null; // キャラクター選択もリセット

                const selectedProject = projects.find(p => p.id === currentProjectId);
                currentProjectTitle.textContent = selectedProject ? selectedProject.name : '作品を選択してください';
                
                // 各リストをレンダリングし、UIの状態を更新
                renderProjectList();
                renderCharacterList();
                renderSequenceList();
                renderSceneList(); // シーンリストはcurrentSequenceIdがnullなので空になるはず

                // メインコンテンツのシーン関連を非表示
                sceneInputSection.style.display = 'none';
                sceneListSection.style.display = 'none';
                sceneDetailsSection.style.display = 'none';
                currentSequenceTitle.style.display = 'none';
                currentSequenceTitle.textContent = ''; // シークエンスタイトルもクリア
                selectedSceneContent.innerHTML = ''; // シーン詳細もクリア
                clearDrawingCanvas();
                imagePreviewElement.innerHTML = '';
                tablePreviewElement.innerHTML = '';

                // 全体概要、キャラクター、シークエンスセクションは表示
                overallSummarySection.style.display = 'block';
                characterListSection.style.display = 'block';
                sequenceListSection.style.display = 'block';

                updateUIState();
                populateCharacterSelectForScene(); // シーン追加時のキャラクター選択肢を更新
                drawTimeline(); // プロジェクト選択時もタイムラインを初期化
            }

            function selectCharacter(characterId) {
                currentCharacterId = characterId;
                const currentProject = projects.find(p => p.id === currentProjectId);
                const selectedChar = currentProject?.characters.find(c => c.id === currentCharacterId);

                if (selectedChar) {
                    charDetailNameInput.value = selectedChar.name;
                    charDetailTraitInput.value = selectedChar.traits || '';
                    charDetailRoleInput.value = selectedChar.role || '';
                    charDetailSummaryTextarea.value = selectedChar.details || '';
                    characterDetailModal.style.display = 'flex'; // モーダル表示

                    // 自動保存のイベントリスナーを設定 (モーダルが閉じる時にまとめて解除されるべきだが、再設定で上書きされるため問題は少ない)
                    charDetailNameInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
                    charDetailTraitInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
                    charDetailRoleInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
                    charDetailSummaryTextarea.addEventListener('input', scheduleAutoSaveCharacterDetail);

                }
                renderCharacterList(); // 選択状態を反映
                updateUIState();
            }

            function selectSequence(sequenceId) {
                currentSequenceId = sequenceId;
                currentSceneId = null; // シークエンスが変わったらシーン選択をリセット
                const currentProject = projects.find(p => p.id === currentProjectId);
                const selectedSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                currentSequenceTitle.textContent = selectedSequence ? selectedSequence.name : '';
                currentSequenceTitle.style.display = 'block';

                // シーン入力とリストを表示
                sceneInputSection.style.display = 'block';
                sceneListSection.style.display = 'block';
                sceneDetailsSection.style.display = 'none'; // シーン詳細を非表示に
                selectedSceneContent.innerHTML = ''; // シーン詳細もクリア
                clearDrawingCanvas();
                imagePreviewElement.innerHTML = '';
                tablePreviewElement.innerHTML = '';

                renderSequenceList(); // 選択状態を反映
                renderSceneList(); // シーンリストを再レンダリング

                updateUIState();
                drawTimeline(); // シークエンスが選択されたらタイムラインを再描画
            }

            function selectScene(sceneId) {
                currentSceneId = sceneId;
                renderSelectedSceneDetails(); // シーン詳細を表示

                // シーン詳細セクションを表示
                sceneDetailsSection.style.display = 'block';
                
                renderSceneList(); // 選択状態を反映
                updateUIState();
                drawTimeline(); // シーンが選択されたらタイムラインを再描画（選択シーンのハイライトのため）
            }

            function resetMainContentVisibility() {
                // メインコンテンツのすべてのセクションを非表示にする初期化関数
                overallSummarySection.style.display = 'none';
                characterListSection.style.display = 'none';
                sequenceListSection.style.display = 'none';
                sceneInputSection.style.display = 'none';
                sceneListSection.style.display = 'none';
                sceneDetailsSection.style.display = 'none';
                currentProjectTitle.textContent = '作品を選択してください';
                currentSequenceTitle.style.display = 'none';
                currentSequenceTitle.textContent = '';
                selectedSceneContent.innerHTML = ''; // シーン詳細もクリア
                clearDrawingCanvas(); // 描画クリア
                imagePreviewElement.innerHTML = ''; // 画像クリア
                tablePreviewElement.innerHTML = ''; // テーブルクリア
            }

            function updateUIState() {
                // 全てのリストの選択状態を更新
                document.querySelectorAll('#project-list li').forEach(li => li.classList.remove('selected'));
                if (currentProjectId) {
                    document.querySelector(`#project-list li[data-id="${currentProjectId}"]`)?.classList.add('selected');
                }
                document.querySelectorAll('#character-list li').forEach(li => li.classList.remove('selected'));
                if (currentCharacterId) {
                    document.querySelector(`#character-list li[data-id="${currentCharacterId}"]`)?.classList.add('selected');
                }
                document.querySelectorAll('#sequence-list li').forEach(li => li.classList.remove('selected'));
                if (currentSequenceId) {
                    document.querySelector(`#sequence-list li[data-id="${currentSequenceId}"]`)?.classList.add('selected');
                }
                document.querySelectorAll('#scene-list li').forEach(li => li.classList.remove('selected'));
                if (currentSceneId) {
                    document.querySelector(`#scene-list li[data-id="${currentSceneId}"]`)?.classList.add('selected');
                }

                // 削除ボタンの有効/無効
                deleteProjectButton.disabled = !currentProjectId;
                deleteCharacterButton.disabled = !currentCharacterId; // currentProjectIdに関わらず、キャラ選択が必須
                deleteSequenceButton.disabled = !currentSequenceId;
                deleteSceneButton.disabled = !currentSceneId;
            }

            // --- 自動保存関連関数 ---
            function debounce(func, delay) {
                return function(...args) {
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            }

            // シーン追加時の入力フィールドの自動保存 (これは「シーンを追加」ボタンで確定されるため、
            // フィールドごとの自動保存は現状は不要と判断しています。もし必要であれば、
            // `editDateInput`などのように各フィールドにイベントリスナーを追加してください。)
            // const scheduleAutoSaveSceneInputs = debounce(() => { /* ... */ }, AUTO_SAVE_DELAY);

            // 選択中のシーン詳細の自動保存
            const scheduleAutoSaveSceneDetails = debounce(() => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);

                if (!currentScene) return;

                let dataChanged = false; // 変更があったかどうかを追跡

                // 各入力フィールドから値を取得し、現在のシーンデータと比較して更新
                if (currentScene.type === 'timeline') {
                    const newDate = document.getElementById('editDate').value.trim();
                    const newEvent = document.getElementById('editEvent').value.trim();
                    if (currentScene.data.date !== newDate) { currentScene.data.date = newDate; dataChanged = true; }
                    if (currentScene.data.event !== newEvent) { currentScene.data.event = newEvent; dataChanged = true; }
                } else if (currentScene.type === 'character') {
                    // charIdが紐付いていない（新規作成されたシーン内キャラ）の場合のみcharNameも更新
                    if (!currentScene.data.charId) {
                        const newCharName = document.getElementById('editCharName').value.trim();
                        if (currentScene.data.charName !== newCharName) { currentScene.data.charName = newCharName; dataChanged = true; }
                    }
                    const newCharTrait = document.getElementById('editCharTrait').value.trim();
                    const newCharRole = document.getElementById('editCharRole').value.trim();
                    if (currentScene.data.charTrait !== newCharTrait) { currentScene.data.charTrait = newCharTrait; dataChanged = true; }
                    if (currentScene.data.charRole !== newCharRole) { currentScene.data.charRole = newCharRole; dataChanged = true; }

                    // 紐付けられたキャラクターの詳細も更新（名前は変更しない）
                    if (currentScene.data.charId) {
                        const charToUpdate = currentProject?.characters.find(c => c.id === currentScene.data.charId);
                        if (charToUpdate) {
                            if (charToUpdate.traits !== newCharTrait) { charToUpdate.traits = newCharTrait; dataChanged = true; }
                            if (charToUpdate.role !== newCharRole) { charToUpdate.role = newCharRole; dataChanged = true; }
                        }
                    }
                } else if (currentScene.type === 'story') {
                    const newStoryChapter = document.getElementById('editStoryChapter').value.trim();
                    const newStorySummary = document.getElementById('editStorySummary').value.trim();
                    const newStoryConflict = document.getElementById('editStoryConflict').value.trim();
                    if (currentScene.data.storyChapter !== newStoryChapter) { currentScene.data.storyChapter = newStoryChapter; dataChanged = true; }
                    if (currentScene.data.storySummary !== newStorySummary) { currentScene.data.storySummary = newStorySummary; dataChanged = true; }
                    if (currentScene.data.storyConflict !== newStoryConflict) { currentScene.data.storyConflict = newStoryConflict; dataChanged = true; }
                }

                if (dataChanged) {
                    saveProjects(true); // 自動保存フラグをtrueに
                    renderSceneList(); // リスト表示が変更された可能性があるので更新
                }
            }, AUTO_SAVE_DELAY);

            // 作品全体概要モーダルの自動保存
            const scheduleAutoSaveOverallSummary = debounce(() => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (currentProject) {
                    if (currentProject.overallSummary !== overallSummaryTextarea.value) {
                        currentProject.overallSummary = overallSummaryTextarea.value;
                        saveProjects(true);
                    }
                }
            }, AUTO_SAVE_DELAY);

            // キャラクター詳細モーダルの自動保存
            const scheduleAutoSaveCharacterDetail = debounce(() => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                const selectedChar = currentProject?.characters.find(c => c.id === currentCharacterId);
                if (selectedChar) {
                    let dataChanged = false;
                    const newName = charDetailNameInput.value.trim();
                    const newTrait = charDetailTraitInput.value.trim();
                    const newRole = charDetailRoleInput.value.trim();
                    const newDetails = charDetailSummaryTextarea.value.trim();

                    if (selectedChar.name !== newName) { selectedChar.name = newName; dataChanged = true; }
                    if (selectedChar.traits !== newTrait) { selectedChar.traits = newTrait; dataChanged = true; }
                    if (selectedChar.role !== newRole) { selectedChar.role = newRole; dataChanged = true; }
                    if (selectedChar.details !== newDetails) { selectedChar.details = newDetails; dataChanged = true; }

                    if (dataChanged) {
                        saveProjects(true);
                        renderCharacterList(); // 名前が変更された場合に備えて更新
                        // シーンリストも更新が必要な場合がある
                        if (currentProjectId && currentSequenceId) {
                            renderSceneList();
                            renderSelectedSceneDetails(); // 選択中のシーン詳細も更新
                        }
                    }
                }
            }, AUTO_SAVE_DELAY);


            // 各入力フィールドに自動保存イベントリスナーをアタッチ
            // これらの要素はHTMLロード時に存在するため、直接イベントリスナーを追加
            dateInput.addEventListener('input', scheduleAutoSaveSceneInputs); // シーン追加フォームの入力
            eventInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            charNameInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            charTraitInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            charRoleInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            storyChapterInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            storySummaryInput.addEventListener('input', scheduleAutoSaveSceneInputs);
            storyConflictInput.addEventListener('input', scheduleAutoSaveSceneInputs);

            // 全体概要モーダルとキャラクター詳細モーダルのテキストエリアにも自動保存を設定
            overallSummaryTextarea.addEventListener('input', scheduleAutoSaveOverallSummary);
            charDetailNameInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
            charDetailTraitInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
            charDetailRoleInput.addEventListener('input', scheduleAutoSaveCharacterDetail);
            charDetailSummaryTextarea.addEventListener('input', scheduleAutoSaveCharacterDetail);


            // --- イベントリスナー ---
            addProjectButton.addEventListener('click', () => {
                const projectName = prompt('新しい作品のタイトルを入力してください:');
                if (projectName) {
                    const newProject = {
                        id: generateId(),
                        name: projectName,
                        overallSummary: '',
                        characters: [],
                        sequences: []
                    };
                    projects.push(newProject);
                    saveProjects();
                    selectProject(newProject.id); // 新しく作った作品を選択状態にする
                }
            });

            // 作品名編集関数
            function editProjectName(projectId) {
                const project = projects.find(p => p.id === projectId);
                if (project) {
                    const newName = prompt(`作品「${project.name}」の新しいタイトルを入力してください:`, project.name);
                    if (newName !== null && newName.trim() !== '' && newName !== project.name) {
                        project.name = newName.trim();
                        saveProjects();
                        renderProjectList();
                        // 選択中の作品名も更新
                        if (currentProjectId === projectId) {
                            currentProjectTitle.textContent = project.name;
                        }
                        alert('作品名を更新しました！');
                    } else if (newName === null) {
                        // キャンセルされた場合
                        alert('作品名の変更をキャンセルしました。');
                    } else if (newName.trim() === '') {
                        alert('作品名は空にできません。');
                    } else if (newName === project.name) {
                        alert('作品名は変更されていません。');
                    }
                }
            }


            deleteProjectButton.addEventListener('click', () => {
                if (!currentProjectId) {
                    alert('削除する作品を選択してください。');
                    return;
                }
                const currentProjectName = projects.find(p => p.id === currentProjectId)?.name;
                if (confirm(`作品「${currentProjectName}」を削除してもよろしいですか？この操作は元に戻せません。`)) {
                    projects = projects.filter(p => p.id !== currentProjectId);
                    currentProjectId = null;
                    currentSequenceId = null;
                    currentSceneId = null;
                    currentCharacterId = null; 
                    saveProjects();
                    renderProjectList(); // 作品リストを再レンダリング
                    resetMainContentVisibility(); // メインコンテンツを完全にリセット
                    updateUIState();
                }
            });

            // キャラクター追加
            addCharacterButton.addEventListener('click', () => {
                if (!currentProjectId) {
                    alert('先に作品を選択または作成してください。');
                    return;
                }
                const charName = prompt('新しいキャラクターの名前を入力してください:');
                if (charName) {
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    if (currentProject) {
                        const newCharacter = {
                            id: generateId(),
                            name: charName,
                            traits: '',
                            role: '',
                            details: ''
                        };
                        currentProject.characters.push(newCharacter);
                        saveProjects();
                        renderCharacterList(); // リストを更新
                        populateCharacterSelectForScene(); // シーンのドロップダウンも更新
                        selectCharacter(newCharacter.id); // 新しいキャラクターを選択し、詳細モーダルを開く
                    }
                }
            });

            // キャラクター削除
            deleteCharacterButton.addEventListener('click', () => {
                if (!currentCharacterId) {
                    alert('削除するキャラクターを選択してください。');
                    return;
                }
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentCharacterName = currentProject?.characters.find(c => c.id === currentCharacterId)?.name;
                if (confirm(`キャラクター「${currentCharacterName}」を削除してもよろしいですか？この操作は元に戻せません。`)) {
                    if (currentProject) {
                        currentProject.characters = currentProject.characters.filter(c => c.id !== currentCharacterId);
                        
                        // 削除されたキャラクターがシーンに紐付いていた場合、シーン内のcharIdをクリア
                        currentProject.sequences.forEach(seq => {
                            seq.scenes.forEach(scene => {
                                if (scene.type === 'character' && scene.data.charId === currentCharacterId) {
                                    delete scene.data.charId; // IDを削除
                                    // オプションで、名前や役割もクリアする
                                    scene.data.charName = '(削除済みキャラクター)'; 
                                    scene.data.charTrait = '';
                                    scene.data.charRole = '';
                                }
                            });
                        });

                        currentCharacterId = null; // 選択解除
                        saveProjects();
                        renderCharacterList(); // リストを更新
                        populateCharacterSelectForScene(); // シーンのドロップダウンも更新
                        // シーンリストも更新が必要な場合がある（削除されたキャラが使われていたシーンの表示更新）
                        if (currentSequenceId) {
                            renderSceneList();
                            renderSelectedSceneDetails(); // もし選択中のシーンが削除されたキャラのものなら、詳細も更新
                        }
                        updateUIState();
                        characterDetailModal.style.display = 'none'; // モーダルを閉じる
                    }
                }
            });

            addSequenceButton.addEventListener('click', () => {
                if (!currentProjectId) {
                    alert('先に作品を選択または作成してください。');
                    return;
                }
                const sequenceName = prompt('新しいシークエンスのタイトルを入力してください:');
                if (sequenceName) {
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    if (currentProject) {
                        const newSequence = {
                            id: generateId(),
                            name: sequenceName,
                            scenes: []
                        };
                        currentProject.sequences.push(newSequence);
                        saveProjects();
                        selectSequence(newSequence.id); // 新しく作ったシークエンスを選択状態にする
                    }
                }
            });

            // シークエンス名編集関数
            function editSequenceName(sequenceId) {
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (!currentProject) return;

                const sequence = currentProject.sequences.find(s => s.id === sequenceId);
                if (sequence) {
                    const newName = prompt(`シークエンス「${sequence.name}」の新しいタイトルを入力してください:`, sequence.name);
                    if (newName !== null && newName.trim() !== '' && newName !== sequence.name) {
                        sequence.name = newName.trim();
                        saveProjects();
                        renderSequenceList();
                        // 選択中のシークエンス名も更新
                        if (currentSequenceId === sequenceId) {
                            currentSequenceTitle.textContent = sequence.name;
                        }
                        alert('シークエンス名を更新しました！');
                    } else if (newName === null) {
                        // キャンセルされた場合
                        alert('シークエンス名の変更をキャンセルしました。');
                    } else if (newName.trim() === '') {
                        alert('シークエンス名は空にできません。');
                    } else if (newName === sequence.name) {
                        alert('シークエンス名は変更されていません。');
                    }
                }
            }

            deleteSequenceButton.addEventListener('click', () => {
                if (!currentSequenceId) {
                    alert('削除するシークエンスを選択してください。');
                    return;
                }
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequenceName = currentProject?.sequences.find(s => s.id === currentSequenceId)?.name;
                if (confirm(`シークエンス「${currentSequenceName}」を削除してもよろしいですか？この操作は元に戻せません。`)) {
                    if (currentProject) {
                        currentProject.sequences = currentProject.sequences.filter(s => s.id !== currentSequenceId);
                        currentSequenceId = null;
                        currentSceneId = null; // シークエンス削除でシーン選択もリセット
                        saveProjects();
                        renderSequenceList(); // シークエンスリストを再描画
                        
                        // シーン関連のUIを非表示に
                        sceneInputSection.style.display = 'none';
                        sceneListSection.style.display = 'none';
                        sceneDetailsSection.style.display = 'none';
                        currentSequenceTitle.style.display = 'none';
                        currentSequenceTitle.textContent = '';
                        selectedSceneContent.innerHTML = '';
                        clearDrawingCanvas();
                        imagePreviewElement.innerHTML = '';
                        tablePreviewElement.innerHTML = '';
                        updateUIState();
                        drawTimeline(); // タイムラインも更新
                    }
                }
            });

            addSceneButton.addEventListener('click', () => {
                if (!currentProjectId || !currentSequenceId) {
                    alert('先に作品とシークエンスを選択してください。');
                    return;
                }

                let newSceneData = {};
                let sceneType = document.querySelector('input[name="plotType"]:checked').value;

                if (sceneType === 'timeline') {
                    const date = dateInput.value.trim();
                    const event = eventInput.value.trim();
                    if (!date || !event) { alert('日付と出来事を入力してください。'); return; }
                    newSceneData = { date, event };
                } else if (sceneType === 'character') {
                    const selectedCharId = characterSelectForScene.value;
                    let charName = charNameInput.value.trim();
                    let charTrait = charTraitInput.value.trim();
                    let charRole = charRoleInput.value.trim();

                    if (selectedCharId) { // 既存のキャラクターを選択した場合
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        const selectedChar = currentProject?.characters.find(c => c.id === selectedCharId);
                        if (selectedChar) {
                            newSceneData = {
                                charId: selectedChar.id, // キャラクターIDを紐付け
                                charName: selectedChar.name, // 名前はシーンにも記録（表示用）
                                charTrait: selectedChar.traits, // シーンにも記録
                                charRole: selectedChar.role // シーンにも記録
                            };
                        }
                    } else { // 新しいキャラクターを追加する場合
                        if (!charName) { alert('キャラクター名を入力してください。'); return; }
                        newSceneData = { charName, charTrait, charRole };

                        // 新しいキャラクターを作品のキャラクターリストにも追加
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        if (currentProject) {
                            if (!currentProject.characters) {
                                currentProject.characters = [];
                            }
                            const newCharacter = {
                                id: generateId(),
                                name: charName,
                                traits: charTrait,
                                role: charRole,
                                details: '' // 新規作成時は空
                            };
                            currentProject.characters.push(newCharacter);
                            newSceneData.charId = newCharacter.id; // シーンにもIDを紐付け
                            saveProjects(); // ここでプロジェクト全体を保存
                            renderCharacterList(); // キャラクターリストを更新
                            populateCharacterSelectForScene(); // ドロップダウンも更新
                        }
                    }
                } else if (sceneType === 'story') {
                    const storyChapter = storyChapterInput.value.trim();
                    const storySummary = storySummaryInput.value.trim();
                    const storyConflict = storyConflictInput.value.trim();
                    if (!storyChapter || !storySummary) { alert('章/シーンと概要を入力してください。'); return; }
                    newSceneData = { storyChapter, storySummary, storyConflict };
                }

                const newScene = {
                    id: generateId(),
                    type: sceneType,
                    data: newSceneData,
                    drawings: [], // 追加時は空で初期化
                    image: null,     // 追加時は空で初期化
                    table: null      // 追加時は空で初期化
                };

                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                if (currentSequence) {
                    currentSequence.scenes.push(newScene);
                    saveProjects();
                    renderSceneList(); // シーンリストを再描画
                    selectScene(newScene.id); // 追加したシーンを選択状態にする
                    clearSceneInputs(); // シーン追加後に入力欄と付属データをクリア
                }
            });

            deleteSceneButton.addEventListener('click', () => {
                if (!currentSceneId) {
                    alert('削除するシーンを選択してください。');
                    return;
                }
                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                
                if (currentSequence) {
                    // シーンの削除
                    currentSequence.scenes = currentSequence.scenes.filter(sc => sc.id !== currentSceneId);
                    currentSceneId = null; // 削除後に選択中のシーンをリセット
                    saveProjects();
                    renderSceneList(); // シーンリストを再描画

                    // シーン詳細セクションを非表示にし、内容をクリア
                    sceneDetailsSection.style.display = 'none';
                    selectedSceneContent.innerHTML = '';
                    clearDrawingCanvas();
                    imagePreviewElement.innerHTML = '';
                    tablePreviewElement.innerHTML = '';
                    updateUIState();
                    drawTimeline(); // タイムラインも更新
                }
            });

            clearSceneInputsButton.addEventListener('click', clearSceneInputs);

            function clearSceneInputs() {
                dateInput.value = '';
                eventInput.value = '';
                charNameInput.value = '';
                charTraitInput.value = '';
                charRoleInput.value = '';
                characterSelectForScene.value = ''; // ドロップダウンもリセット
                charNameInput.disabled = false; // 新規入力欄を有効に
                charTraitInput.disabled = false;
                charRoleInput.disabled = false;

                storyChapterInput.value = '';
                storySummaryInput.value = '';
                storyConflictInput.value = '';

                // 描画・画像・テーブルの一時データをクリア
                currentDrawingData = [];
                clearDrawingCanvas();
                currentImageData = null;
                imagePreviewElement.innerHTML = '';
                currentTableData = null;
                tablePreviewElement.innerHTML = '';
            }

            // プロットタイプ切り替え
            radioButtons.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const plotType = event.target.value;
                    timelineInputs.style.display = 'none';
                    characterInputs.style.display = 'none';
                    storyInputs.style.display = 'none';
                    if (plotType === 'timeline') {
                        timelineInputs.style.display = 'block';
                    } else if (plotType === 'character') {
                        characterInputs.style.display = 'block';
                        populateCharacterSelectForScene(); // キャラクター選択肢を更新
                    } else if (plotType === 'story') {
                        storyInputs.style.display = 'block';
                    }
                    clearSceneInputs(); // 入力フォーム切り替え時もクリア
                });
            });

            // シーンのキャラクタープロット入力時に既存キャラクターを選択するためのドロップダウンを生成
            function populateCharacterSelectForScene() {
                characterSelectForScene.innerHTML = '<option value="">-- 新しいキャラクター --</option>';
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (currentProject && currentProject.characters) {
                    currentProject.characters.forEach(char => {
                        const option = document.createElement('option');
                        option.value = char.id;
                        option.textContent = char.name;
                        characterSelectForScene.appendChild(option);
                    });
                }
            }

            // ドロップダウン選択時、名前・特徴・役割の入力欄を無効化/有効化
            characterSelectForScene.addEventListener('change', () => {
                const isExistingCharSelected = characterSelectForScene.value !== '';
                charNameInput.disabled = isExistingCharSelected;
                charTraitInput.disabled = isExistingCharSelected;
                charRoleInput.disabled = isExistingCharSelected;

                // 既存キャラクターを選択した場合、その情報を入力欄に表示（編集は不可だが参考用）
                if (isExistingCharSelected) {
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const selectedChar = currentProject?.characters.find(c => c.id === characterSelectForScene.value);
                    if (selectedChar) {
                        charNameInput.value = selectedChar.name;
                        charTraitInput.value = selectedChar.traits;
                        charRoleInput.value = selectedChar.role;
                    }
                } else {
                    charNameInput.value = '';
                    charTraitInput.value = '';
                    charRoleInput.value = '';
                }
            });


            // --- 全体概要モーダル関連 ---
            openOverallSummaryModalButton.addEventListener('click', () => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (currentProject) {
                    overallSummaryTextarea.value = currentProject.overallSummary || '';
                    overallSummaryModal.style.display = 'flex'; // Flexboxで中央表示
                }
            });

            closeOverallSummaryModalButton.addEventListener('click', () => {
                overallSummaryModal.style.display = 'none';
            });

            // モーダルの外側クリックで閉じる
            overallSummaryModal.addEventListener('click', (event) => {
                if (event.target === overallSummaryModal) {
                    overallSummaryModal.style.display = 'none';
                }
            });

            saveOverallSummaryButton.addEventListener('click', () => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                if (currentProject) {
                    currentProject.overallSummary = overallSummaryTextarea.value;
                    saveProjects();
                    alert('全体概要を保存しました！');
                    overallSummaryModal.style.display = 'none';
                }
            });

            // --- キャラクター詳細モーダル関連 ---
            // キャラクターリストのクリックイベントはrenderCharacterList内で設定
            closeCharacterDetailModalButton.addEventListener('click', () => {
                characterDetailModal.style.display = 'none';
                currentCharacterId = null; // 選択解除
                updateUIState();
                renderCharacterList(); // 選択解除をUIに反映
            });

            characterDetailModal.addEventListener('click', (event) => {
                if (event.target === characterDetailModal) {
                    characterDetailModal.style.display = 'none';
                    currentCharacterId = null; // 選択解除
                    updateUIState();
                    renderCharacterList(); // 選択解除をUIに反映
                }
            });

            saveCharacterDetailButton.addEventListener('click', () => {
                const currentProject = projects.find(p => p.id === currentProjectId);
                const selectedChar = currentProject?.characters.find(c => c.id === currentCharacterId);
                if (selectedChar) {
                    selectedChar.name = charDetailNameInput.value.trim();
                    selectedChar.traits = charDetailTraitInput.value.trim();
                    selectedChar.role = charDetailRoleInput.value.trim();
                    selectedChar.details = charDetailSummaryTextarea.value.trim();
                    saveProjects();
                    alert('キャラクター詳細を保存しました！');
                    characterDetailModal.style.display = 'none';
                    renderCharacterList(); // リスト表示を更新
                    populateCharacterSelectForScene(); // シーンのドロップダウンも更新
                    // キャラクター名が変更された場合、シーンリストの表示も更新する必要がある
                    if (currentProjectId && currentSequenceId) { // 現在作品とシークエンスが選択されていれば
                        renderSceneList();
                        renderSelectedSceneDetails(); // 選択中のシーン詳細も更新
                    }
                }
            });


            // --- 描画機能 ---
            function clearDrawingCanvas() {
                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }

            function drawAllDrawings() {
                clearDrawingCanvas();
                drawingContext.lineCap = 'round'; // 線端のスタイル
                drawingContext.lineJoin = 'round'; // 線結合部のスタイル

                currentDrawingData.forEach(path => {
                    drawingContext.beginPath();
                    drawingContext.strokeStyle = path.color;
                    drawingContext.lineWidth = path.thickness;
                    if (path.points.length > 0) {
                        drawingContext.moveTo(path.points[0].x, path.points[0].y);
                        for(let i = 1; i < path.points.length; i++) {
                            drawingContext.lineTo(path.points[i].x, path.points[i].y);
                        }
                    }
                    drawingContext.stroke();
                });
            }

            drawingModeButton.addEventListener('click', () => {
                isDrawingMode = !isDrawingMode;
                drawingModeButton.textContent = isDrawingMode ? '描画モード終了' : '描画モード開始';
                drawingModeButton.classList.toggle('danger', isDrawingMode);
                drawingCanvas.style.cursor = isDrawingMode ? 'crosshair' : 'default';
                if (!currentSceneId && isDrawingMode) {
                    alert('シーンが選択されていません。描画は一時的で、シーンに保存されません。シーンを選択してから描画を開始してください。');
                    isDrawingMode = false; // シーンがない場合は描画モードを強制終了
                    drawingModeButton.textContent = '描画モード開始';
                    drawingModeButton.classList.remove('danger');
                    drawingCanvas.style.cursor = 'default';
                    return;
                } else if (isDrawingMode) {
                     alert('描画モードを開始しました。');
                } else {
                    alert('描画モードを終了しました。');
                }
            });

            drawingCanvas.addEventListener('mousedown', (e) => {
                if (!isDrawingMode || !currentSceneId) return;
                isDrawing = true;
                const rect = drawingCanvas.getBoundingClientRect();
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;
                drawingPath = [{ x: lastX, y: lastY }];
            });

            drawingCanvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !isDrawingMode || !currentSceneId) return;
                const rect = drawingCanvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                drawingContext.beginPath();
                drawingContext.moveTo(lastX, lastY);
                drawingContext.lineTo(currentX, currentY);
                drawingContext.strokeStyle = lineColorInput.value;
                drawingContext.lineWidth = lineThicknessInput.value;
                drawingContext.stroke();

                drawingPath.push({ x: currentX, y: currentY });
                lastX = currentX;
                lastY = currentY;
            });

            drawingCanvas.addEventListener('mouseup', () => {
                if (isDrawing && isDrawingMode && currentSceneId) {
                    currentDrawingData.push({
                        points: drawingPath,
                        color: lineColorInput.value,
                        thickness: lineThicknessInput.value
                    });
                    isDrawing = false;
                    // シーンが選択されていれば、描画データをシーンに保存
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                    const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                    if (currentScene) {
                        currentScene.drawings = currentDrawingData;
                        saveProjects(true); // 自動保存
                    }
                }
            });

            // モバイルデバイス向けタッチイベント
            drawingCanvas.addEventListener('touchstart', (e) => {
                if (!isDrawingMode || !currentSceneId) return;
                e.preventDefault(); // スクロールなどを防ぐ
                isDrawing = true;
                const rect = drawingCanvas.getBoundingClientRect();
                lastX = e.touches[0].clientX - rect.left;
                lastY = e.touches[0].clientY - rect.top;
                drawingPath = [{ x: lastX, y: lastY }];
            });

            drawingCanvas.addEventListener('touchmove', (e) => {
                if (!isDrawing || !isDrawingMode || !currentSceneId) return;
                e.preventDefault(); // スクロールなどを防ぐ
                const rect = drawingCanvas.getBoundingClientRect();
                const currentX = e.touches[0].clientX - rect.left;
                const currentY = e.touches[0].clientY - rect.top;

                drawingContext.beginPath();
                drawingContext.moveTo(lastX, lastY);
                drawingContext.lineTo(currentX, currentY);
                drawingContext.strokeStyle = lineColorInput.value;
                drawingContext.lineWidth = lineThicknessInput.value;
                drawingContext.stroke();

                drawingPath.push({ x: currentX, y: currentY });
                lastX = currentX;
                lastY = currentY;
            });

            drawingCanvas.addEventListener('touchend', () => {
                if (isDrawing && isDrawingMode && currentSceneId) {
                    currentDrawingData.push({
                        points: drawingPath,
                        color: lineColorInput.value,
                        thickness: lineThicknessInput.value
                    });
                    isDrawing = false;
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                    const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                    if (currentScene) {
                        currentScene.drawings = currentDrawingData;
                        saveProjects(true); // 自動保存
                    }
                }
            });

            clearDrawingButton.addEventListener('click', () => {
                if (confirm('描画を全てクリアしますか？')) {
                    clearDrawingCanvas();
                    currentDrawingData = [];
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                    const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                    if (currentScene) {
                        currentScene.drawings = currentDrawingData; // 空の配列を保存
                        saveProjects(); // 手動保存なのでアラートは残す
                        alert('描画をクリアして保存しました。');
                    } else {
                        alert('描画をクリアしました。'); // シーンが選択されていなくてもCanvasはクリア
                    }
                }
            });


            // --- 画像アップロード ---
            imageUploadInput.addEventListener('change', (event) => {
                if (!currentSceneId) {
                    alert('画像を保存するにはシーンを選択してください。');
                    imageUploadInput.value = ''; // ファイル選択をリセット
                    return;
                }
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        currentImageData = { dataUrl: e.target.result, name: file.name };
                        const img = document.createElement('img');
                        img.src = currentImageData.dataUrl;
                        imagePreviewElement.innerHTML = '';
                        imagePreviewElement.appendChild(img);

                        // シーンが選択されていれば、画像データをシーンに保存
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                        const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                        if (currentScene) {
                            currentScene.image = currentImageData;
                            saveProjects(); // 画像は自動保存しない（手動アップロード完了時のみ）
                            alert('画像を保存しました。');
                        }
                    };
                    reader.readAsDataURL(file);
                } else { // ファイルが選択されずに変更された（例えばキャンセルされた）場合
                    currentImageData = null;
                    imagePreviewElement.innerHTML = '';
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                    const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                    if (currentScene) {
                        delete currentScene.image; // 画像データを削除
                        saveProjects(); // 手動保存
                        alert('画像を削除しました。');
                    }
                }
            });

            // --- テーブル作成 ---
            function renderTablePreview(data) {
                if (!data || data.length === 0) {
                    tablePreviewElement.innerHTML = '';
                    return;
                }
                const table = document.createElement('table');
                table.innerHTML = ''; // クリア

                data.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    row.forEach((cell, colIndex) => {
                        const td = document.createElement('td');
                        td.textContent = cell;
                        td.contentEditable = true; // インライン編集可能にする
                        td.dataset.rowIndex = rowIndex;
                        td.dataset.colIndex = colIndex;
                        td.addEventListener('blur', (e) => { // blurイベントで自動保存
                            // 編集内容をcurrentTableDataに反映
                            currentTableData[parseInt(e.target.dataset.rowIndex)][parseInt(e.target.dataset.colIndex)] = e.target.textContent;
                            // シーンが選択されていれば、テーブルデータをシーンに保存
                            const currentProject = projects.find(p => p.id === currentProjectId);
                            const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                            const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                            if (currentScene) {
                                currentScene.table = currentTableData;
                                saveProjects(true); // 自動保存
                            }
                        });
                        tr.appendChild(td);
                    });
                    table.appendChild(tr);
                });
                tablePreviewElement.innerHTML = '';
                tablePreviewElement.appendChild(table);
            }

            createTableButton.addEventListener('click', () => {
                if (!currentSceneId) {
                    alert('テーブルを保存するにはシーンを選択してください。');
                    return;
                }
                const rows = parseInt(tableRowsInput.value) || 3;
                const cols = parseInt(tableColsInput.value) || 3;
                if (rows > 0 && cols > 0) {
                    currentTableData = Array.from({ length: rows }, () => Array(cols).fill(''));
                    renderTablePreview(currentTableData);
                    // シーンが選択されていれば、テーブルデータをシーンに保存
                    const currentProject = projects.find(p => p.id === currentProjectId);
                    const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                    const currentScene = currentSequence?.scenes.find(sc => sc.id === currentSceneId);
                    if (currentScene) {
                        currentScene.table = currentTableData;
                        saveProjects(); // 手動保存なのでアラートは残す
                        alert('テーブルを作成・保存しました。');
                    }
                } else {
                    alert('行数と列数は1以上で指定してください。');
                }
            });

            // --- タイムライン描画 ---
            function drawTimeline() {
                timelineContext.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
                timelineContext.font = '12px Arial';
                timelineContext.fillStyle = '#333';
                timelineContext.textAlign = 'center';
                timelineContext.strokeStyle = '#ccc';
                timelineContext.lineWidth = 1;

                const currentProject = projects.find(p => p.id === currentProjectId);
                const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);

                if (!currentSequence || currentSequence.scenes.length === 0) {
                    timelineContext.fillText('このシークエンスにはシーンがありません。', timelineCanvas.width / 2, timelineCanvas.height / 2);
                    return;
                }

                // タイムライン軸の描画
                const startX = 50;
                const endX = timelineCanvas.width - 50;
                const lineY = timelineCanvas.height / 2;
                timelineContext.beginPath();
                timelineContext.moveTo(startX, lineY);
                timelineContext.lineTo(endX, lineY);
                timelineContext.stroke();

                // 各シーンをタイムライン上に配置
                const sceneCount = currentSequence.scenes.length;
                // シーンが1つの場合は間隔を0にする (線上に1点だけ描画)
                const spacing = (sceneCount > 1) ? (endX - startX) / (sceneCount - 1) : 0; 

                currentSequence.scenes.forEach((scene, index) => {
                    const x = startX + (index * spacing);
                    const y = lineY;

                    // 目盛り
                    timelineContext.beginPath();
                    timelineContext.moveTo(x, y - 5);
                    timelineContext.lineTo(x, y + 5);
                    timelineContext.stroke();

                    // シーン名（データに応じて表示を調整）
                    let sceneLabel = '';
                    if (scene.type === 'timeline' && scene.data.date) {
                        sceneLabel = scene.data.date;
                    } else if (scene.type === 'character') {
                        // シーンが持つcharNameを使用、またはcharIdから作品のキャラクター名を取得
                        sceneLabel = scene.data.charName || (currentProject?.characters.find(c => c.id === scene.data.charId)?.name || `👤 シーン${index + 1}`);
                    } else if (scene.type === 'story' && scene.data.storyChapter) {
                        sceneLabel = scene.data.storyChapter;
                    } else {
                        sceneLabel = `シーン ${index + 1}`;
                    }

                    // テキストを回転させて表示
                    timelineContext.save();
                    timelineContext.translate(x, y + 15);
                    timelineContext.rotate(Math.PI / 6); // 30度回転
                    timelineContext.fillText(sceneLabel, 0, 0);
                    timelineContext.restore();

                    // 選択中のシーンをハイライト
                    if (scene.id === currentSceneId) {
                        timelineContext.beginPath();
                        timelineContext.arc(x, y, 8, 0, Math.PI * 2);
                        timelineContext.fillStyle = '#3498db';
                        timelineContext.fill();
                        timelineContext.strokeStyle = '#2980b9';
                        timelineContext.lineWidth = 2;
                        timelineContext.stroke();
                    }
                });
            }

            timelineDisplayModeButton.addEventListener('click', () => {
                // 現在のプロジェクトとシークエンスが選択されている場合のみ描画
                if (currentProjectId && currentSequenceId) {
                    drawTimeline();
                } else {
                    alert('タイムラインを表示するには、作品とシークエンスを選択してください。');
                }
            });

            // --- ドラッグ＆ドロップ機能 ---
            function addDragAndDropListeners(listElement) {
                listElement.querySelectorAll('li').forEach(item => {
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragenter', handleDragEnter);
                    item.addEventListener('dragover', handleDragOver);
                    item.addEventListener('dragleave', handleDragLeave);
                    item.addEventListener('drop', handleDrop);
                    item.addEventListener('dragend', handleDragEnd);
                });
            }

            function handleDragStart(e) {
                draggedItem = e.target;
                dragType = draggedItem.dataset.type; // project, character, sequence, scene
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedItem.dataset.id); // ドラッグする要素のIDをセット
                e.dataTransfer.setData('text/dragtype', dragType); // ドラッグする要素のタイプをセット

                setTimeout(() => {
                    draggedItem.classList.add('dragging'); // ドラッグ中の要素を半透明にする
                }, 0); // DOMが更新されるのを待つ
            }

            function handleDragEnter(e) {
                e.preventDefault(); // ドロップを許可するために必要
                // draggedItemがnull（ドラッグ開始前）または自分自身である場合は処理しない
                if (!draggedItem || e.target === draggedItem || e.target.dataset.type !== dragType) return;
                
                // ドロップ対象の要素がリストアイテムであることを確認
                let targetLi = e.target.closest('li[draggable="true"]');
                if (targetLi && targetLi.dataset.type === dragType) {
                    // 他のアイテムのハイライトをクリア
                    document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                        item.classList.remove('drag-over', 'drag-over-bottom');
                    });

                    // ドロップする位置を判定（上半分なら上、下半分なら下）
                    const rect = targetLi.getBoundingClientRect();
                    const offset = e.clientY - rect.top;
                    if (offset < rect.height / 2) {
                        targetLi.classList.add('drag-over'); // 上に挿入
                    } else {
                        targetLi.classList.add('drag-over-bottom'); // 下に挿入
                    }
                }
            }

            function handleDragOver(e) {
                e.preventDefault(); // ドロップを許可するために必要
                e.dataTransfer.dropEffect = 'move'; // マウスカーソルを移動のアイコンにする

                // ドロップ対象の要素がリストアイテムであることを確認
                let targetLi = e.target.closest('li[draggable="true"]');
                if (targetLi && targetLi.dataset.type === dragType) {
                    // 他のアイテムのハイライトをクリア
                    document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                        item.classList.remove('drag-over', 'drag-over-bottom');
                    });

                    // ドロップする位置を判定（上半分なら上、下半分なら下）
                    const rect = targetLi.getBoundingClientRect();
                    const offset = e.clientY - rect.top;
                    if (offset < rect.height / 2) {
                        targetLi.classList.add('drag-over'); // 上に挿入
                    } else {
                        targetLi.classList.add('drag-over-bottom'); // 下に挿入
                    }
                }
            }

            function handleDragLeave(e) {
                e.target.classList.remove('drag-over', 'drag-over-bottom'); // ドロップゾーンから出たらハイライトを解除
            }

            function handleDrop(e) {
                e.preventDefault();
                // ドロップ時のハイライトを解除
                document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                    item.classList.remove('drag-over', 'drag-over-bottom');
                });

                if (draggedItem && draggedItem !== e.target) {
                    const dropTargetId = e.target.dataset.id;
                    const dropTargetType = e.target.dataset.type;
                    const draggedId = e.dataTransfer.getData('text/plain');
                    const receivedDragType = e.dataTransfer.getData('text/dragtype');

                    if (dragType !== receivedDragType || dragType !== dropTargetType) {
                        // 異なる種類のアイテム間でのドラッグ＆ドロップは許可しない
                        console.warn('異なる種類のアイテム間でのドラッグ＆ドロップは許可されていません。');
                        return;
                    }

                    let listArray;
                    let renderFunction;
                    let targetObject;
                    let draggedObject;

                    // リストの種類に応じて適切な配列とレンダリング関数を選択
                    if (dragType === 'project') {
                        listArray = projects;
                        renderFunction = renderProjectList;
                    } else if (dragType === 'character') {
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        if (!currentProject) return;
                        listArray = currentProject.characters;
                        renderFunction = renderCharacterList;
                    } else if (dragType === 'sequence') {
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        if (!currentProject) return;
                        listArray = currentProject.sequences;
                        renderFunction = renderSequenceList;
                    } else if (dragType === 'scene') {
                        const currentProject = projects.find(p => p.id === currentProjectId);
                        const currentSequence = currentProject?.sequences.find(s => s.id === currentSequenceId);
                        if (!currentSequence) return;
                        listArray = currentSequence.scenes;
                        renderFunction = renderSceneList;
                    } else {
                        return; // 未知のタイプ
                    }

                    // ドラッグされた要素とドロップ先の要素を配列から見つける
                    draggedObject = listArray.find(item => item.id === draggedId);
                    targetObject = listArray.find(item => item.id === dropTargetId);

                    if (draggedObject && targetObject) {
                        const draggedIndex = listArray.indexOf(draggedObject);
                        let targetIndex = listArray.indexOf(targetObject);

                        // 要素を配列から削除
                        listArray.splice(draggedIndex, 1);

                        // ドロップ位置に応じて挿入位置を調整
                        const rect = e.target.getBoundingClientRect();
                        const offset = e.clientY - rect.top;
                        if (offset > rect.height / 2) {
                            // ドロップ対象の下に挿入する場合
                            listArray.splice(targetIndex + 1, 0, draggedObject);
                        } else {
                            // ドロップ対象の上に挿入する場合
                            listArray.splice(targetIndex, 0, draggedObject);
                        }
                        
                        saveProjects(); // 変更を保存
                        renderFunction(); // リストを再レンダリング

                        // 現在選択中のアイテムが並べ替え後も選択状態を維持するように調整
                        // もしドラッグされたアイテムが選択中だった場合、再度選択し直すことでハイライトが維持される
                        if (dragType === 'project' && draggedId === currentProjectId) selectProject(draggedId);
                        if (dragType === 'character' && draggedId === currentCharacterId) selectCharacter(draggedId);
                        if (dragType === 'sequence' && draggedId === currentSequenceId) selectSequence(draggedId);
                        if (dragType === 'scene' && draggedId === currentSceneId) selectScene(draggedId);
                        else updateUIState(); // それ以外の場合は選択状態を更新

                        if (dragType === 'scene' && currentSequenceId) {
                            drawTimeline(); // シーンが並べ替えられたらタイムラインを再描画
                        }
                    }
                }
            }

            function handleDragEnd(e) {
                draggedItem.classList.remove('dragging'); // ドラッグ中の要素から半透明を解除
                document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                    item.classList.remove('drag-over', 'drag-over-bottom'); // 残っているハイライトを解除
                });
                draggedItem = null;
                dragType = null;
            }

            // --- 初期化 ---
            loadProjects(); // アプリ起動時に保存されたプロジェクトを読み込む

            // 最後に選択されていたプロジェクトなどを記憶・復元するロジック (簡易版)
            // ページロード時に、もし以前に選択されていた作品があればそれを選択状態にする
            const lastSelectedProjectId = localStorage.getItem('lastSelectedProjectId');
            if (lastSelectedProjectId && projects.some(p => p.id === lastSelectedProjectId)) {
                selectProject(lastSelectedProjectId);
            } else if (projects.length > 0) {
                selectProject(projects[0].id); // 以前の選択がなければ最初の作品を選択
            } else {
                resetMainContentVisibility(); // プロジェクトが一つもない場合はUIを初期状態に
            }
            updateUIState(); // UIの初期状態を更新
        });
    </script>
</body>
</html>
