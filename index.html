<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>プロットメーカー PRO</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #app {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 90%;
            max-width: 1000px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
        }
        #sidebar {
            width: 250px;
            padding-right: 20px;
            border-right: 1px solid #eee;
            flex-shrink: 0;
        }
        #main-content {
            flex-grow: 1;
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        .list-container {
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            background-color: #fcfcfc;
        }
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: grab; /* ドラッグ可能であることを示す */
            transition: background-color 0.2s ease, transform 0.2s ease;
            user-select: none;
        }
        .list-item:last-child {
            border-bottom: none;
        }
        .list-item:hover {
            background-color: #eef;
        }
        .list-item.selected {
            background-color: #dbe9f5;
            font-weight: bold;
        }
        .list-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
        .drag-over {
            border-top: 2px solid #3498db;
            background-color: #e0f2f7;
        }
        .drag-over-bottom {
            border-bottom: 2px solid #3498db;
            background-color: #e0f2f7;
        }
        .list-item span {
            flex-grow: 1;
            padding-right: 10px;
        }
        .list-item button {
            padding: 5px 10px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .button-group {
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 700px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* プロットタイプ選択 */
        #plotTypeSelect {
            margin-bottom: 15px;
        }
        .plot-fields {
            border: 1px dashed #ccc;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #fafafa;
        }

        /* Canvas スタイル */
        /* #drawingCanvas { */
            /* cursor: crosshair; */
        /* } */
        #timelineCanvas {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            background-color: white;
            display: block; /* ensure it's a block element */
        }
        /* .canvas-tools { */
        /* margin-bottom: 10px; */
        /* display: flex; */
        /* align-items: center; */
        /* gap: 10px; */
        /* flex-wrap: wrap; */
        /* } */
        /* .canvas-tools label { */
        /* margin-right: 5px; */
        /* display: inline-block; */
        /* margin-bottom: 0; */
        /* } */
        /* .canvas-tools input[type="color"] { */
        /* width: 40px; */
        /* height: 30px; */
        /* padding: 0; */
        /* border: none; */
        /* vertical-align: middle; */
        /* } */
        /* .canvas-tools input[type="range"] { */
        /* width: 80px; */
        /* vertical-align: middle; */
        /* } */

        /* 画像プレビュー */
        #imagePreview {
            max-width: 100%;
            max-height: 200px;
            overflow: hidden;
            border: 1px solid #eee;
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }
        #imagePreview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #imageUploadInput {
            margin-bottom: 10px;
        }
        .image-upload-area {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .image-upload-area button {
             margin-top: 10px;
        }


        /* テーブル */
        #tablePreview {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        #tablePreview th, #tablePreview td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
            min-width: 50px;
        }
        #tablePreview td[contenteditable="true"]:focus {
            outline: 2px solid #3498db;
            background-color: #e8f5fd;
        }
        .table-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        .table-controls input {
            width: 80px;
            margin-bottom: 0;
        }

        /* メインコンテンツ非表示時のスタイル */
        #main-content > div:not(#noProjectMessage) {
            display: none;
        }
        #noProjectMessage {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #666;
        }

        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            #app {
                flex-direction: column;
                padding: 15px;
            }
            #sidebar {
                width: 100%;
                padding-right: 0;
                border-right: none;
                border-bottom: 1px solid #eee;
                margin-bottom: 20px;
            }
            #sidebar h2 {
                margin-top: 0;
            }
            .list-container {
                max-height: 200px;
            }
            .canvas-tools, .table-controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <h1>プロットメーカー PRO</h1>
    <div id="app">
        <aside id="sidebar">
            <h2>作品</h2>
            <button id="addProjectButton">新しい作品</button>
            <div class="list-container" id="projectList">
                </div>
            <div class="button-group">
                <button id="deleteProjectButton" disabled>作品を削除</button>
            </div>

            <h2>キャラクター</h2>
            <button id="addCharacterButton" disabled>新しいキャラクター</button>
            <div class="list-container" id="characterList">
                </div>
            <div class="button-group">
                <button id="deleteCharacterButton" disabled>キャラクターを削除</button>
            </div>

            <h2>シークエンス</h2>
            <button id="addSequenceButton" disabled>新しいシークエンス</button>
            <div class="list-container" id="sequenceList">
                </div>
            <div class="button-group">
                <button id="deleteSequenceButton" disabled>シークエンスを削除</button>
            </div>
        </aside>

        <main id="main-content">
            <div id="noProjectMessage">
                <p>左のサイドバーから「新しい作品」を作成するか、既存の作品を選択してください。</p>
            </div>

            <div id="overallSummaryModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeSummaryModalButton">&times;</span>
                    <h3>作品全体概要</h3>
                    <textarea id="overallSummaryTextarea" placeholder="作品全体のあらすじや設定などを記入"></textarea>
                    <button id="saveOverallSummaryButton">保存</button>
                </div>
            </div>

            <div id="characterDetailModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeCharacterDetailModalButton">&times;</span>
                    <h3>キャラクター詳細</h3>
                    <label for="characterNameInput">名前:</label>
                    <input type="text" id="characterNameInput" placeholder="キャラクター名">

                    <label for="characterTraitInput">特徴/性格:</label>
                    <textarea id="characterTraitInput" placeholder="性格や特徴を記入"></textarea>

                    <label for="characterRoleInput">役割:</label>
                    <input type="text" id="characterRoleInput" placeholder="作品内での役割">

                    <label for="characterDetailMemoInput">詳細メモ:</label>
                    <textarea id="characterDetailMemoInput" placeholder="詳細な背景、関係性などを記入"></textarea>

                    <button id="saveCharacterDetailButton">保存</button>
                </div>
            </div>

            <div id="sceneManagementArea">
                <h2>選択中の作品: <span id="currentProjectName"></span></h2>
                <div class="button-group">
                    <button id="openOverallSummaryButton">概要メモを開く</button>
                </div>

                <h2>選択中のシークエンス: <span id="currentSequenceName"></span></h2>

                <h3>新しいシーンを追加</h3>
                <div class="plot-fields">
                    <label for="plotTypeSelect">プロットタイプ:</label>
                    <select id="plotTypeSelect">
                        <option value="time">時系列プロット</option>
                        <option value="character">キャラクタープロット</option>
                        <option value="story">ストーリープロット</option>
                    </select>

                    <div id="timePlotFields" class="plot-fields-group">
                        <label for="dateInput">日付/時期:</label>
                        <input type="text" id="dateInput" placeholder="例: 2023/01/15, 翌日, 数週間後">
                        <label for="eventInput">出来事/内容:</label>
                        <textarea id="eventInput" placeholder="その時起こった出来事や状況を具体的に記述"></textarea>
                    </div>

                    <div id="characterPlotFields" class="plot-fields-group" style="display: none;">
                        <label for="characterSelect">キャラクター選択:</label>
                        <select id="characterSelect">
                            <option value="">既存キャラクターを選択</option>
                            </select>
                        <button id="addNewCharacterToSceneButton">シーンから新キャラクター登録</button>
                        <label for="sceneCharacterNameInput">キャラクター名 (新規の場合):</label>
                        <input type="text" id="sceneCharacterNameInput" placeholder="新しいキャラクター名">
                        <label for="sceneCharacterTraitInput">特徴/性格:</label>
                        <textarea id="sceneCharacterTraitInput" placeholder="性格や特徴を記入"></textarea>
                        <label for="sceneCharacterRoleInput">役割:</label>
                        <input type="text" id="sceneCharacterRoleInput" placeholder="このシーンでの役割">
                    </div>

                    <div id="storyPlotFields" class="plot-fields-group" style="display: none;">
                        <label for="chapterSceneInput">章/シーン名:</label>
                        <input type="text" id="chapterSceneInput" placeholder="例: 第1章, 遭遇, ターニングポイント">
                        <label for="summaryInput">概要:</label>
                        <textarea id="summaryInput" placeholder="シーンのあらすじ、目的、舞台設定など"></textarea>
                        <label for="conflictResolutionInput">葛藤/解決:</label>
                        <textarea id="conflictResolutionInput" placeholder="シーン内の問題、対立、その解決、または次の問題への移行"></textarea>
                    </div>

                    <button id="addSceneButton">シーンを追加</button>
                    <button id="clearSceneInputButton">入力クリア</button>
                </div>

                <h3>シーンリスト</h3>
                <div class="list-container" id="sceneList">
                    </div>
                <div class="button-group">
                    <button id="deleteSceneButton" disabled>シーンを削除</button>
                </div>

                <h3>選択中のシーン詳細</h3>
                <div id="selectedSceneDetails" style="border: 1px solid #ddd; padding: 15px; border-radius: 5px; background-color: #f9f9f9; min-height: 100px;">
                    <div id="timePlotDetailFields" class="plot-detail-group" style="display: none;">
                        <label for="detailDateInput">日付/時期:</label>
                        <input type="text" id="detailDateInput">
                        <label for="detailEventInput">出来事/内容:</label>
                        <textarea id="detailEventInput"></textarea>
                    </div>

                    <div id="characterPlotDetailFields" class="plot-detail-group" style="display: none;">
                        <label for="detailCharacterSelect">キャラクター:</label>
                        <select id="detailCharacterSelect"></select>
                        <label for="detailSceneCharacterNameInput">キャラクター名:</label>
                        <input type="text" id="detailSceneCharacterNameInput">
                        <label for="detailSceneCharacterTraitInput">特徴/性格:</label>
                        <textarea id="detailSceneCharacterTraitInput"></textarea>
                        <label for="detailSceneCharacterRoleInput">役割:</label>
                        <input type="text" id="detailSceneCharacterRoleInput">
                    </div>

                    <div id="storyPlotDetailFields" class="plot-detail-group" style="display: none;">
                        <label for="detailChapterSceneInput">章/シーン名:</label>
                        <input type="text" id="detailChapterSceneInput">
                        <label for="detailSummaryInput">概要:</label>
                        <textarea id="detailSummaryInput"></textarea>
                        <label for="detailConflictResolutionInput">葛藤/解決:</label>
                        <textarea id="detailConflictResolutionInput"></textarea>
                    </div>

                    <button id="saveSceneDetailsButton">シーン内容を保存</button>
                </div>

                <h3>画像エリア</h3>
                <div class="image-upload-area">
                    <input type="file" id="imageUploadInput" accept="image/*">
                    <div id="imagePreview">画像がここに表示されます</div>
                    <button id="clearImageButton">画像をクリア</button>
                </div>

                <h3>テーブルエリア</h3>
                <div class="table-area">
                    <div class="table-controls">
                        <label for="tableRowsInput">行数:</label>
                        <input type="number" id="tableRowsInput" value="3" min="1">
                        <label for="tableColsInput">列数:</label>
                        <input type="number" id="tableColsInput" value="3" min="1">
                        <button id="createTableButton">テーブル作成</button>
                    </div>
                    <table id="tablePreview">
                        </table>
                </div>

                <h3>タイムライン</h3>
                <button id="toggleTimelineModeButton">タイムライン表示を更新</button>
                <canvas id="timelineCanvas"></canvas>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM要素の取得 ---
            const app = document.getElementById('app');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const noProjectMessage = document.getElementById('noProjectMessage');
            const sceneManagementArea = document.getElementById('sceneManagementArea');

            // 作品関連
            const addProjectButton = document.getElementById('addProjectButton');
            const projectList = document.getElementById('projectList');
            const deleteProjectButton = document.getElementById('deleteProjectButton');
            const currentProjectNameSpan = document.getElementById('currentProjectName');
            const openOverallSummaryButton = document.getElementById('openOverallSummaryButton');
            const overallSummaryModal = document.getElementById('overallSummaryModal');
            const closeSummaryModalButton = document.getElementById('closeSummaryModalButton');
            const overallSummaryTextarea = document.getElementById('overallSummaryTextarea');
            const saveOverallSummaryButton = document.getElementById('saveOverallSummaryButton');

            // キャラクター関連
            const addCharacterButton = document.getElementById('addCharacterButton');
            const characterList = document.getElementById('characterList');
            const deleteCharacterButton = document.getElementById('deleteCharacterButton');
            const characterDetailModal = document.getElementById('characterDetailModal');
            const closeCharacterDetailModalButton = document.getElementById('closeCharacterDetailModalButton');
            const characterNameInput = document.getElementById('characterNameInput');
            const characterTraitInput = document.getElementById('characterTraitInput');
            const characterRoleInput = document.getElementById('characterRoleInput');
            const characterDetailMemoInput = document.getElementById('characterDetailMemoInput');
            const saveCharacterDetailButton = document.getElementById('saveCharacterDetailButton');

            // シークエンス関連
            const addSequenceButton = document.getElementById('addSequenceButton');
            const sequenceList = document.getElementById('sequenceList');
            const deleteSequenceButton = document.getElementById('deleteSequenceButton');
            const currentSequenceNameSpan = document.getElementById('currentSequenceName');

            // シーン入力関連
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const timePlotFields = document.getElementById('timePlotFields');
            const characterPlotFields = document.getElementById('characterPlotFields');
            const storyPlotFields = document.getElementById('storyPlotFields');
            const dateInput = document.getElementById('dateInput');
            const eventInput = document.getElementById('eventInput');
            const characterSelect = document.getElementById('characterSelect');
            const addNewCharacterToSceneButton = document.getElementById('addNewCharacterToSceneButton');
            const sceneCharacterNameInput = document.getElementById('sceneCharacterNameInput');
            const sceneCharacterTraitInput = document.getElementById('sceneCharacterTraitInput');
            const sceneCharacterRoleInput = document.getElementById('sceneCharacterRoleInput');
            const chapterSceneInput = document.getElementById('chapterSceneInput');
            const summaryInput = document.getElementById('summaryInput');
            const conflictResolutionInput = document.getElementById('conflictResolutionInput');
            const addSceneButton = document.getElementById('addSceneButton');
            const clearSceneInputButton = document.getElementById('clearSceneInputButton');
            const sceneList = document.getElementById('sceneList');
            const deleteSceneButton = document.getElementById('deleteSceneButton');

            // シーン詳細表示関連
            const selectedSceneDetails = document.getElementById('selectedSceneDetails');
            const timePlotDetailFields = document.getElementById('timePlotDetailFields');
            const characterPlotDetailFields = document.getElementById('characterPlotDetailFields');
            const storyPlotDetailFields = document.getElementById('storyPlotDetailFields');
            const detailDateInput = document.getElementById('detailDateInput');
            const detailEventInput = document.getElementById('detailEventInput');
            const detailCharacterSelect = document.getElementById('detailCharacterSelect');
            const detailSceneCharacterNameInput = document.getElementById('detailSceneCharacterNameInput');
            const detailSceneCharacterTraitInput = document.getElementById('detailSceneCharacterTraitInput');
            const detailSceneCharacterRoleInput = document.getElementById('detailSceneCharacterRoleInput');
            const detailChapterSceneInput = document.getElementById('detailChapterSceneInput');
            const detailSummaryInput = document.getElementById('detailSummaryInput');
            const detailConflictResolutionInput = document.getElementById('detailConflictResolutionInput');
            const saveSceneDetailsButton = document.getElementById('saveSceneDetailsButton');

            // 描画関連 (廃止のためコメントアウト)
            // const drawingCanvas = document.getElementById('drawingCanvas');
            // const drawingCtx = drawingCanvas.getContext('2d');
            // const strokeColorInput = document.getElementById('strokeColor');
            // const strokeWidthInput = document.getElementById('strokeWidth');
            // const toggleDrawModeButton = document.getElementById('toggleDrawModeButton');
            // const clearDrawingButton = document.getElementById('clearDrawingButton');

            // 画像関連
            const imageUploadInput = document.getElementById('imageUploadInput');
            const imagePreview = document.getElementById('imagePreview');
            const clearImageButton = document.getElementById('clearImageButton');

            // テーブル関連
            const tableRowsInput = document.getElementById('tableRowsInput');
            const tableColsInput = document.getElementById('tableColsInput');
            const createTableButton = document.getElementById('createTableButton');
            const tablePreview = document.getElementById('tablePreview');

            // タイムライン関連
            const timelineCanvas = document.getElementById('timelineCanvas');
            const timelineCtx = timelineCanvas.getContext('2d');
            const toggleTimelineModeButton = document.getElementById('toggleTimelineModeButton');

            // --- グローバル変数 ---
            let projects = [];
            let currentProjectId = null;
            let currentCharacterId = null;
            let currentSequenceId = null;
            let currentSceneId = null;

            // 描画用変数 (廃止のためコメントアウト)
            // let isDrawing = false;
            // let drawModeEnabled = true; // 描画モードの初期状態
            // let lastX = 0;
            // let lastY = 0;

            // 画像用変数
            let currentImageData = null;

            // テーブル用変数
            let currentTableData = [];

            // ドラッグ＆ドロップ用変数
            let draggedItem = null;
            let dragType = null; // 'project', 'character', 'sequence', 'scene'

            // オートセーブタイマー
            let autoSaveTimer;
            const AUTOSAVE_DELAY = 1000; // 1秒

            // --- ヘルパー関数 ---
            function generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substring(2);
            }

            function saveProjects() {
                localStorage.setItem('plotMakerProjects', JSON.stringify(projects));
                console.log('Projects saved:', projects);
            }

            function loadProjects() {
                const storedProjects = localStorage.getItem('plotMakerProjects');
                if (storedProjects) {
                    projects = JSON.parse(storedProjects);
                }
                renderProjectList();
            }

            // UI状態の更新（ボタンの有効/無効、表示/非表示など）
            function updateUIState() {
                const selectedProject = projects.find(p => p.id === currentProjectId);
                const selectedSequence = selectedProject && selectedProject.sequences.find(s => s.id === currentSequenceId);

                // メインコンテンツの表示制御
                if (selectedProject) {
                    noProjectMessage.style.display = 'none';
                    sceneManagementArea.style.display = 'block';
                    currentProjectNameSpan.textContent = selectedProject.name; // 作品名表示
                } else {
                    noProjectMessage.style.display = 'block';
                    sceneManagementArea.style.display = 'none';
                    currentProjectNameSpan.textContent = '';
                }

                // 作品ボタン
                deleteProjectButton.disabled = !currentProjectId;
                openOverallSummaryButton.disabled = !currentProjectId; // 作品概要ボタンも制御

                // キャラクターボタン
                addCharacterButton.disabled = !currentProjectId;
                deleteCharacterButton.disabled = !currentCharacterId;

                // シークエンスボタン
                addSequenceButton.disabled = !currentProjectId;
                deleteSequenceButton.disabled = !currentSequenceId;
                currentSequenceNameSpan.textContent = selectedSequence ? selectedSequence.name : ''; // シークエンス名表示

                // シーンボタン
                addSceneButton.disabled = !currentSequenceId;
                clearSceneInputButton.disabled = !currentSequenceId;
                deleteSceneButton.disabled = !currentSceneId;
                saveSceneDetailsButton.disabled = !currentSceneId;


                // シーン詳細フィールドの表示制御
                // まず全て非表示
                ['timePlotDetailFields', 'characterPlotDetailFields', 'storyPlotDetailFields']
                    .forEach(id => document.getElementById(id).style.display = 'none');
                // シーンが選択されていれば詳細エリア自体を表示
                selectedSceneDetails.style.display = currentSceneId ? 'block' : 'none';

                // 描画・画像・テーブルの表示/非表示
                // drawingCanvas.style.display = currentSceneId ? 'block' : 'none'; // 廃止のためコメントアウト
                // document.querySelector('.drawing-area .canvas-tools').style.display = currentSceneId ? 'flex' : 'none'; // 廃止のためコメントアウト

                imageUploadInput.style.display = currentSceneId ? 'block' : 'none';
                imagePreview.style.display = currentSceneId ? 'flex' : 'none';
                clearImageButton.style.display = currentSceneId ? 'block' : 'none';
                document.querySelector('.image-upload-area').style.display = currentSceneId ? 'block' : 'none';


                tableRowsInput.style.display = currentSceneId ? 'inline-block' : 'none';
                tableColsInput.style.display = currentSceneId ? 'inline-block' : 'none';
                createTableButton.style.display = currentSceneId ? 'inline-block' : 'none';
                // tablePreviewの表示はrenderTablePreview()内で制御
                document.querySelector('.table-area .table-controls').style.display = currentSceneId ? 'flex' : 'none';

                timelineCanvas.style.display = currentSequenceId ? 'block' : 'none';
                toggleTimelineModeButton.style.display = currentSequenceId ? 'block' : 'none';


                renderProjectList();
                renderCharacterList();
                renderSequenceList();
                renderSceneList();
                drawTimeline(); // UI更新時にタイムラインも更新
            }

            function resetMainContentVisibility() {
                noProjectMessage.style.display = 'block';
                sceneManagementArea.style.display = 'none';
                currentProjectNameSpan.textContent = '';
                currentSequenceNameSpan.textContent = '';
                currentProjectId = null;
                currentCharacterId = null;
                currentSequenceId = null;
                currentSceneId = null;
                clearSceneDetails();
                // clearDrawing(); // 廃止のためコメントアウト
                clearImagePreview();
                clearTable();
                updateUIState(); // リセット後、最終的なUI状態を更新
            }

            // --- 作品関連関数 ---
            function renderProjectList() {
                projectList.innerHTML = '';
                projects.forEach(project => {
                    const listItem = createListItem(project.name, project.id, 'project');
                    projectList.appendChild(listItem);

                    if (project.id === currentProjectId) {
                        listItem.classList.add('selected');
                    }
                });
            }

            function selectProject(id) {
                currentProjectId = id;
                const project = projects.find(p => p.id === id);
                if (project) {
                    // 作品選択時に、対応するシークエンスリストの最初のシークエンスを選択するか、何もない場合はnullにする
                    if (project.sequences.length > 0) {
                        selectSequence(project.sequences[0].id);
                    } else {
                        currentSequenceId = null; // シークエンスがない場合はクリア
                        currentSceneId = null; // シーンもクリア
                        currentSequenceNameSpan.textContent = '';
                        renderSceneList(); // シーンリストをクリア
                        clearSceneInput(); // シーン入力フォームもクリア
                        clearSceneDetails(); // シーン詳細もクリア
                        // clearDrawing(); // 廃止のためコメントアウト
                        clearImagePreview();
                        clearTable();
                        drawTimeline(); // タイムラインもクリア
                    }
                    // キャラクターリストも更新
                    currentCharacterId = null; // 作品が変わったらキャラクターの選択もリセット
                } else {
                    resetMainContentVisibility(); // プロジェクトが見つからない場合はリセット
                }
                localStorage.setItem('lastSelectedProjectId', id); // 最後に選択したプロジェクトを記憶
                updateUIState(); // UI全体を更新
            }

            // --- キャラクター関連関数 ---
            function renderCharacterList() {
                characterList.innerHTML = '';
                const selectedProject = projects.find(p => p.id === currentProjectId);
                if (selectedProject) {
                    selectedProject.characters.forEach(character => {
                        const listItem = createListItem(character.name, character.id, 'character');
                        characterList.appendChild(listItem);
                        if (character.id === currentCharacterId) {
                            listItem.classList.add('selected');
                        }
                    });
                }
            }

            function selectCharacter(id) {
                currentCharacterId = id;
                const selectedProject = projects.find(p => p.id === currentProjectId);
                const character = selectedProject ? selectedProject.characters.find(c => c.id === id) : null;

                if (character) {
                    characterNameInput.value = character.name;
                    characterTraitInput.value = character.trait;
                    characterRoleInput.value = character.role;
                    characterDetailMemoInput.value = character.detailMemo;
                    characterDetailModal.style.display = 'flex';
                }
                updateUIState();
            }

            function updateCharacterSelects() {
                const selectedProject = projects.find(p => p.id === currentProjectId);
                const characters = selectedProject ? selectedProject.characters : [];

                characterSelect.innerHTML = '<option value="">既存キャラクターを選択</option>';
                detailCharacterSelect.innerHTML = '<option value="">選択してください</option>';
                characters.forEach(char => {
                    const option1 = document.createElement('option');
                    option1.value = char.id;
                    option1.textContent = char.name;
                    characterSelect.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = char.id;
                    option2.textContent = char.name;
                    detailCharacterSelect.appendChild(option2);
                });

                // シーン入力フォームのキャラクター選択が、現在の詳細と一致するように設定
                if (currentSceneId) { // シーンが選択されている場合のみ更新を試みる
                    const selectedScene = findScene(currentSceneId);
                    if (selectedScene && selectedScene.type === 'character') {
                        characterSelect.value = selectedScene.characterId || '';
                        sceneCharacterNameInput.value = selectedScene.sceneCharacterName || '';
                        sceneCharacterTraitInput.value = selectedScene.sceneCharacterTrait || '';
                        sceneCharacterRoleInput.value = selectedScene.sceneCharacterRole || '';
                    }
                }
            }

            // --- シークエンス関連関数 ---
            function renderSequenceList() {
                sequenceList.innerHTML = '';
                const selectedProject = projects.find(p => p.id === currentProjectId);
                if (selectedProject) {
                    selectedProject.sequences.forEach(sequence => {
                        const listItem = createListItem(sequence.name, sequence.id, 'sequence');
                        sequenceList.appendChild(listItem);
                        if (sequence.id === currentSequenceId) {
                            listItem.classList.add('selected');
                        }
                    });
                }
            }

            function selectSequence(id) {
                currentSequenceId = id;
                const selectedProject = projects.find(p => p.id === currentProjectId);
                const sequence = selectedProject ? selectedProject.sequences.find(s => s.id === id) : null;
                if (sequence) {
                    // シークエンス選択時に、対応するシーンリストの最初のシーンを選択するか、何もない場合はnullにする
                    if (sequence.scenes.length > 0) {
                        selectScene(sequence.scenes[0].id);
                    } else {
                        currentSceneId = null; // シーンがない場合はクリア
                        clearSceneInput(); // シーン入力フォームもクリア
                        clearSceneDetails(); // シーン詳細もクリア
                        // clearDrawing(); // 廃止のためコメントアウト
                        clearImagePreview();
                        clearTable();
                    }
                } else {
                    currentSequenceId = null;
                    currentSceneId = null;
                    clearSceneInput();
                    clearSceneDetails();
                    // clearDrawing(); // 廃止のためコメントアウト
                    clearImagePreview();
                    clearTable();
                }
                renderSceneList();
                drawTimeline(); // シークエンス選択時にタイムラインを再描画
                updateUIState();
            }

            // --- シーン関連関数 ---
            function renderSceneList() {
                sceneList.innerHTML = '';
                const selectedProject = projects.find(p => p.id === currentProjectId);
                const selectedSequence = selectedProject ? selectedProject.sequences.find(s => s.id === currentSequenceId) : null;

                if (selectedSequence) {
                    selectedSequence.scenes.forEach(scene => {
                        let sceneName = '';
                        if (scene.type === 'time') {
                            sceneName = `${scene.date || '日付不明'}: ${scene.event ? scene.event.substring(0, 30) + (scene.event.length > 30 ? '...' : '') : '内容不明'}`;
                        } else if (scene.type === 'character') {
                            const character = selectedProject.characters.find(c => c.id === scene.characterId);
                            const charName = character ? character.name : scene.sceneCharacterName || '新規キャラ';
                            sceneName = `[${charName}] ${scene.sceneCharacterRole ? scene.sceneCharacterRole.substring(0, 20) + (scene.sceneCharacterRole.length > 20 ? '...' : '') : '役割不明'}`;
                        } else if (scene.type === 'story') {
                            sceneName = `${scene.chapterScene || 'シーン名不明'}: ${scene.summary ? scene.summary.substring(0, 30) + (scene.summary.length > 30 ? '...' : '') : '概要不明'}`;
                        }
                        const listItem = createListItem(sceneName, scene.id, 'scene');
                        sceneList.appendChild(listItem);
                        if (scene.id === currentSceneId) {
                            listItem.classList.add('selected');
                        }
                    });
                }
            }

            function selectScene(id) {
                currentSceneId = id;
                const selectedScene = findScene(id);

                clearSceneDetails(); // まず詳細表示をクリア
                hidePlotDetailFields(); // 全ての詳細フィールドを非表示に

                if (selectedScene) {
                    // プロットタイプ選択の表示は不要 (入力フォームは現在のシーンを編集するためのものではない)
                    // plotTypeSelect.value = selectedScene.type; // この行はコメントアウト

                    if (selectedScene.type === 'time') {
                        timePlotDetailFields.style.display = 'block';
                        detailDateInput.value = selectedScene.date || '';
                        detailEventInput.value = selectedScene.event || '';
                    } else if (selectedScene.type === 'character') {
                        characterPlotDetailFields.style.display = 'block';
                        updateCharacterSelects(); // 最新のキャラクターリストで更新
                        detailCharacterSelect.value = selectedScene.characterId || '';
                        detailSceneCharacterNameInput.value = selectedScene.sceneCharacterName || '';
                        detailSceneCharacterTraitInput.value = selectedScene.sceneCharacterTrait || '';
                        detailSceneCharacterRoleInput.value = selectedScene.sceneCharacterRole || '';
                    } else if (selectedScene.type === 'story') {
                        storyPlotDetailFields.style.display = 'block';
                        detailChapterSceneInput.value = selectedScene.chapterScene || '';
                        detailSummaryInput.value = selectedScene.summary || '';
                        detailConflictResolutionInput.value = selectedScene.conflictResolution || '';
                    }

                    // 描画データの読み込み (廃止のためコメントアウト)
                    // drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    // if (selectedScene.drawingData) {
                    //     const img = new Image();
                    //     img.onload = () => {
                    //         drawingCtx.drawImage(img, 0, 0, drawingCanvas.width / (window.devicePixelRatio || 1), drawingCanvas.height / (window.devicePixelRatio || 1));
                    //     };
                    //     img.src = selectedScene.drawingData;
                    // }

                    // 画像データの読み込み
                    imagePreview.innerHTML = '';
                    if (selectedScene.imageData && selectedScene.imageData.dataUrl) {
                        currentImageData = selectedScene.imageData;
                        const img = document.createElement('img');
                        img.src = currentImageData.dataUrl;
                        imagePreview.appendChild(img);
                    } else {
                        currentImageData = null;
                        imagePreview.innerHTML = '画像がここに表示されます'; // 画像がない場合はテキスト表示
                    }

                    // テーブルデータの読み込み
                    currentTableData = selectedScene.tableData || [];
                    renderTablePreview(currentTableData);

                } else {
                    clearSceneDetails();
                    // clearDrawing(); // 廃止のためコメントアウト
                    clearImagePreview();
                    clearTable();
                }
                drawTimeline(); // シーン選択時にタイムラインも更新
                updateUIState(); // UI全体を更新
            }

            function clearSceneInput() {
                dateInput.value = '';
                eventInput.value = '';
                characterSelect.value = '';
                sceneCharacterNameInput.value = '';
                sceneCharacterTraitInput.value = '';
                sceneCharacterRoleInput.value = '';
                chapterSceneInput.value = '';
                summaryInput.value = '';
                conflictResolutionInput.value = '';
            }

            function clearSceneDetails() {
                detailDateInput.value = '';
                detailEventInput.value = '';
                detailCharacterSelect.value = '';
                detailSceneCharacterNameInput.value = '';
                detailSceneCharacterTraitInput.value = '';
                detailSceneCharacterRoleInput.value = '';
                detailChapterSceneInput.value = '';
                detailSummaryInput.value = '';
                detailConflictResolutionInput.value = '';
            }

            function hidePlotDetailFields() {
                timePlotDetailFields.style.display = 'none';
                characterPlotDetailFields.style.display = 'none';
                storyPlotDetailFields.style.display = 'none';
            }

            function findProject(projectId) {
                return projects.find(p => p.id === projectId);
            }

            function findSequence(sequenceId) {
                const project = findProject(currentProjectId);
                return project ? project.sequences.find(s => s.id === sequenceId) : null;
            }

            function findScene(sceneId) {
                const sequence = findSequence(currentSequenceId);
                return sequence ? sequence.scenes.find(sc => sc.id === sceneId) : null;
            }


            // --- UI要素作成ヘルパー ---
            function createListItem(name, id, type) {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                listItem.dataset.id = id;
                listItem.dataset.type = type;
                listItem.draggable = true;

                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                listItem.appendChild(nameSpan);

                // 編集ボタン（作品、キャラクター、シークエンスのみ）
                if (type === 'project' || type === 'character' || type === 'sequence') {
                    const editButton = document.createElement('button');
                    editButton.textContent = '編集';
                    editButton.classList.add('edit-button');
                    editButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // 親要素のクリックイベントが発火しないように
                        const newName = prompt(`新しい${type === 'project' ? '作品' : type === 'character' ? 'キャラクター' : 'シークエンス'}名を入力してください:`, name);
                        if (newName && newName.trim() !== '') {
                            if (type === 'project') {
                                const project = findProject(id);
                                if (project) project.name = newName.trim();
                                if (id === currentProjectId) currentProjectNameSpan.textContent = newName.trim();
                            } else if (type === 'character') {
                                const project = findProject(currentProjectId);
                                const character = project ? project.characters.find(c => c.id === id) : null;
                                if (character) character.name = newName.trim();
                                if (id === currentCharacterId) characterNameInput.value = newName.trim(); // 詳細モーダルも更新
                            } else if (type === 'sequence') {
                                const sequence = findSequence(id);
                                if (sequence) sequence.name = newName.trim();
                                if (id === currentSequenceId) currentSequenceNameSpan.textContent = newName.trim();
                            }
                            saveProjects();
                            updateUIState(); // UIを再描画
                        }
                    });
                    listItem.appendChild(editButton);
                }

                listItem.addEventListener('click', () => {
                    if (type === 'project') selectProject(id);
                    else if (type === 'character') selectCharacter(id);
                    else if (type === 'sequence') selectSequence(id);
                    else if (type === 'scene') selectScene(id);
                });

                // ドラッグ＆ドロップイベントリスナー
                listItem.addEventListener('dragstart', handleDragStart);
                listItem.addEventListener('dragover', handleDragOver);
                listItem.addEventListener('dragleave', handleDragLeave);
                listItem.addEventListener('drop', handleDrop);
                listItem.addEventListener('dragend', handleDragEnd);

                // タッチイベント対応
                listItem.addEventListener('touchstart', handleTouchStart, { passive: true });
                listItem.addEventListener('touchmove', handleTouchMove, { passive: false }); // touchmoveはpreventDefaultするためpassive: false
                listItem.addEventListener('touchend', handleTouchEnd, { passive: true });


                return listItem;
            }


            // --- イベントリスナー ---

            // 作品追加ボタン
            addProjectButton.addEventListener('click', () => {
                const projectName = prompt('新しい作品のタイトルを入力してください:');
                if (projectName && projectName.trim() !== '') {
                    const newProject = {
                        id: generateId(),
                        name: projectName.trim(),
                        overallSummary: '',
                        characters: [],
                        sequences: []
                    };
                    projects.push(newProject);
                    saveProjects();
                    selectProject(newProject.id); // 新しく作った作品を選択状態にする
                }
            });

            // 作品削除ボタン
            deleteProjectButton.addEventListener('click', () => {
                if (currentProjectId && confirm('本当にこの作品を削除しますか？\n（キャラクター、シークエンス、シーン、描画データも全て削除されます）')) {
                    projects = projects.filter(p => p.id !== currentProjectId);
                    currentProjectId = null;
                    currentSequenceId = null;
                    currentSceneId = null;
                    currentCharacterId = null;
                    saveProjects();
                    resetMainContentVisibility(); // 全てのUIを初期状態に戻す
                    if (projects.length > 0) {
                        selectProject(projects[0].id); // 最初の作品を選択
                    }
                }
            });

            // 作品概要モーダル表示
            openOverallSummaryButton.addEventListener('click', () => {
                const selectedProject = findProject(currentProjectId);
                if (selectedProject) {
                    overallSummaryTextarea.value = selectedProject.overallSummary;
                    overallSummaryModal.style.display = 'flex'; // flexで表示
                }
            });

            // 作品概要モーダル閉じる
            closeSummaryModalButton.addEventListener('click', () => {
                overallSummaryModal.style.display = 'none';
            });

            // 作品概要保存
            saveOverallSummaryButton.addEventListener('click', () => {
                const selectedProject = findProject(currentProjectId);
                if (selectedProject) {
                    selectedProject.overallSummary = overallSummaryTextarea.value;
                    saveProjects();
                    // alert('概要を保存しました！'); // アラートは不要な場合も
                    overallSummaryModal.style.display = 'none';
                }
            });

            // キャラクター追加ボタン
            addCharacterButton.addEventListener('click', () => {
                const characterName = prompt('新しいキャラクターの名前を入力してください:');
                if (characterName && characterName.trim() !== '') {
                    const selectedProject = findProject(currentProjectId);
                    if (selectedProject) {
                        const newCharacter = {
                            id: generateId(),
                            name: characterName.trim(),
                            trait: '',
                            role: '',
                            detailMemo: ''
                        };
                        selectedProject.characters.push(newCharacter);
                        saveProjects();
                        selectCharacter(newCharacter.id); // 作成後、詳細モーダルを開く
                    }
                }
            });

            // キャラクター削除ボタン
            deleteCharacterButton.addEventListener('click', () => {
                if (currentProjectId && currentCharacterId && confirm('このキャラクターを削除しますか？')) {
                    const selectedProject = findProject(currentProjectId);
                    if (selectedProject) {
                        selectedProject.characters = selectedProject.characters.filter(c => c.id !== currentCharacterId);
                        // シーン内のキャラクターID参照も削除
                        selectedProject.sequences.forEach(seq => {
                            seq.scenes.forEach(scene => {
                                if (scene.type === 'character' && scene.characterId === currentCharacterId) {
                                    scene.characterId = null; // 紐付けを解除
                                    scene.sceneCharacterName = '(削除済み)'; // 代替テキスト
                                }
                            });
                        });
                        currentCharacterId = null;
                        saveProjects();
                        updateUIState();
                        characterDetailModal.style.display = 'none'; // 詳細モーダルも閉じる
                    }
                }
            });

            // キャラクター詳細モーダル閉じる
            closeCharacterDetailModalButton.addEventListener('click', () => {
                characterDetailModal.style.display = 'none';
                currentCharacterId = null; // 選択状態を解除
                updateUIState(); // UIを更新して選択をクリア
            });

            // キャラクター詳細保存
            saveCharacterDetailButton.addEventListener('click', () => {
                const selectedProject = findProject(currentProjectId);
                const character = selectedProject ? selectedProject.characters.find(c => c.id === currentCharacterId) : null;
                if (character) {
                    character.name = characterNameInput.value.trim();
                    character.trait = characterTraitInput.value.trim();
                    character.role = characterRoleInput.value.trim();
                    character.detailMemo = characterDetailMemoInput.value.trim();
                    saveProjects();
                    updateUIState(); // リストを再描画して名前の変更を反映
                    characterDetailModal.style.display = 'none';
                    // alert('キャラクター情報を保存しました！'); // アラートは不要な場合も
                }
            });

            // シークエンス追加ボタン
            addSequenceButton.addEventListener('click', () => {
                const sequenceName = prompt('新しいシークエンス名を入力してください:');
                if (sequenceName && sequenceName.trim() !== '') {
                    const selectedProject = findProject(currentProjectId);
                    if (selectedProject) {
                        const newSequence = {
                            id: generateId(),
                            name: sequenceName.trim(),
                            scenes: []
                        };
                        selectedProject.sequences.push(newSequence);
                        saveProjects();
                        selectSequence(newSequence.id); // 新しく作ったシークエンスを選択状態にする
                    }
                }
            });

            // シークエンス削除ボタン
            deleteSequenceButton.addEventListener('click', () => {
                if (currentProjectId && currentSequenceId && confirm('本当にこのシークエンスを削除しますか？\n（このシークエンス内のシーン、描画データも全て削除されます）')) {
                    const selectedProject = findProject(currentProjectId);
                    if (selectedProject) {
                        selectedProject.sequences = selectedProject.sequences.filter(s => s.id !== currentSequenceId);
                        currentSequenceId = null;
                        currentSceneId = null; // シークエンス削除時はシーンもクリア
                        saveProjects();
                        updateUIState();
                        // 削除後、残っているシークエンスがあれば最初のものを選択
                        if (selectedProject.sequences.length > 0) {
                            selectSequence(selectedProject.sequences[0].id);
                        } else {
                            currentSequenceNameSpan.textContent = ''; // シークエンスがなくなったら名前もクリア
                            renderSceneList(); // シーンリストをクリア
                            clearSceneInput();
                            clearSceneDetails();
                            // clearDrawing(); // 廃止のためコメントアウト
                            clearImagePreview();
                            clearTable();
                            drawTimeline();
                        }
                    }
                }
            });

            // プロットタイプ選択時の表示切り替え
            plotTypeSelect.addEventListener('change', updatePlotFieldsVisibility);

            function updatePlotFieldsVisibility() {
                timePlotFields.style.display = 'none';
                characterPlotFields.style.display = 'none';
                storyPlotFields.style.display = 'none';

                if (plotTypeSelect.value === 'time') {
                    timePlotFields.style.display = 'block';
                } else if (plotTypeSelect.value === 'character') {
                    characterPlotFields.style.display = 'block';
                    updateCharacterSelects(); // キャラクターリストを更新
                } else if (plotTypeSelect.value === 'story') {
                    storyPlotFields.style.display = 'block';
                }
            }
            updatePlotFieldsVisibility(); // 初期表示

            // シーン入力フォームの新規キャラクター登録ボタン
            addNewCharacterToSceneButton.addEventListener('click', () => {
                const newCharName = sceneCharacterNameInput.value.trim();
                if (newCharName === '') {
                    alert('新しいキャラクター名を入力してください。');
                    return;
                }
                const selectedProject = findProject(currentProjectId);
                if (selectedProject) {
                    const existingChar = selectedProject.characters.find(c => c.name === newCharName);
                    if (existingChar) {
                        alert('その名前のキャラクターは既に存在します。');
                        characterSelect.value = existingChar.id; // 既存を選択状態に
                        return;
                    }
                    const newCharacter = {
                        id: generateId(),
                        name: newCharName,
                        trait: sceneCharacterTraitInput.value.trim(),
                        role: sceneCharacterRoleInput.value.trim(),
                        detailMemo: '' // シーンからの登録なのでメモは空
                    };
                    selectedProject.characters.push(newCharacter);
                    saveProjects();
                    updateCharacterSelects(); // ドロップダウンを更新
                    characterSelect.value = newCharacter.id; // 新しいキャラクターを選択状態に
                    // alert(`「${newCharName}」をキャラクターリストに追加しました。`); // アラートは不要な場合も
                }
            });

            // シーン追加ボタン
            addSceneButton.addEventListener('click', () => {
                const selectedSequence = findSequence(currentSequenceId);
                if (!selectedSequence) {
                    alert('先にシークエンスを選択してください。');
                    return;
                }

                let newScene = { id: generateId(), type: plotTypeSelect.value, drawingData: null, imageData: null, tableData: [] };

                if (plotTypeSelect.value === 'time') {
                    newScene.date = dateInput.value.trim();
                    newScene.event = eventInput.value.trim();
                    if (!newScene.event) { alert('出来事/内容を入力してください。'); return; }
                } else if (plotTypeSelect.value === 'character') {
                    const charId = characterSelect.value;
                    const sceneCharName = sceneCharacterNameInput.value.trim();

                    if (!charId && !sceneCharName) {
                        alert('既存キャラクターを選択するか、新しいキャラクター名を入力してください。');
                        return;
                    }

                    if (charId) {
                        newScene.characterId = charId;
                        const selectedProject = findProject(currentProjectId);
                        const existingChar = selectedProject ? selectedProject.characters.find(c => c.id === charId) : null;
                        newScene.sceneCharacterName = existingChar ? existingChar.name : ''; // 既存キャラ名
                    } else {
                        // 新規キャラクターをシーンから追加する場合
                        const selectedProject = findProject(currentProjectId);
                        if (selectedProject) {
                            const newChar = {
                                id: generateId(),
                                name: sceneCharName,
                                trait: sceneCharacterTraitInput.value.trim(),
                                role: sceneCharacterRoleInput.value.trim(),
                                detailMemo: ''
                            };
                            selectedProject.characters.push(newChar);
                            newScene.characterId = newChar.id;
                            newScene.sceneCharacterName = newChar.name;
                            updateCharacterSelects(); // キャラクターリストとドロップダウンを更新
                        }
                    }
                    newScene.sceneCharacterTrait = sceneCharacterTraitInput.value.trim();
                    newScene.sceneCharacterRole = sceneCharacterRoleInput.value.trim();
                    if (!newScene.sceneCharacterRole) { alert('このシーンでの役割を入力してください。'); return; }

                } else if (plotTypeSelect.value === 'story') {
                    newScene.chapterScene = chapterSceneInput.value.trim();
                    newScene.summary = summaryInput.value.trim();
                    newScene.conflictResolution = conflictResolutionInput.value.trim();
                    if (!newScene.summary) { alert('概要を入力してください。'); return; }
                }

                selectedSequence.scenes.push(newScene);
                saveProjects();
                selectScene(newScene.id); // 新しく作ったシーンを選択
                clearSceneInput(); // 入力フォームをクリア
                updateUIState();
            });

            // シーン入力クリアボタン
            clearSceneInputButton.addEventListener('click', clearSceneInput);


            // シーン削除ボタン
            deleteSceneButton.addEventListener('click', () => {
                if (currentSequenceId && currentSceneId && confirm('本当にこのシーンを削除しますか？')) {
                    const selectedSequence = findSequence(currentSequenceId);
                    if (selectedSequence) {
                        selectedSequence.scenes = selectedSequence.scenes.filter(s => s.id !== currentSceneId);
                        currentSceneId = null;
                        saveProjects();
                        updateUIState();
                        // 削除後、残っているシーンがあれば最初のものを選択
                        if (selectedSequence.scenes.length > 0) {
                            selectScene(selectedSequence.scenes[0].id);
                        } else {
                            clearSceneDetails();
                            // clearDrawing(); // 廃止のためコメントアウト
                            clearImagePreview();
                            clearTable();
                            drawTimeline();
                        }
                    }
                }
            });

            // シーン詳細の入力フィールドでの自動保存（イベントリスナーをまとめて設定）
            [detailDateInput, detailEventInput, detailCharacterSelect,
             detailSceneCharacterNameInput, detailSceneCharacterTraitInput, detailSceneCharacterRoleInput,
             detailChapterSceneInput, detailSummaryInput, detailConflictResolutionInput]
            .forEach(input => {
                input.addEventListener('input', () => {
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = setTimeout(() => {
                        saveSceneDetails();
                    }, AUTOSAVE_DELAY);
                });
            });

            // シーン内容保存ボタン
            saveSceneDetailsButton.addEventListener('click', saveSceneDetails);

            function saveSceneDetails() {
                if (!currentSceneId) return;

                const selectedScene = findScene(currentSceneId);
                if (!selectedScene) return;

                if (selectedScene.type === 'time') {
                    selectedScene.date = detailDateInput.value.trim();
                    selectedScene.event = detailEventInput.value.trim();
                } else if (selectedScene.type === 'character') {
                    selectedScene.characterId = detailCharacterSelect.value;
                    selectedScene.sceneCharacterName = detailSceneCharacterNameInput.value.trim();
                    selectedScene.sceneCharacterTrait = detailSceneCharacterTraitInput.value.trim();
                    selectedScene.sceneCharacterRole = detailSceneCharacterRoleInput.value.trim();
                } else if (selectedScene.type === 'story') {
                    selectedScene.chapterScene = detailChapterSceneInput.value.trim();
                    selectedScene.summary = detailSummaryInput.value.trim();
                    selectedScene.conflictResolution = detailConflictResolutionInput.value.trim();
                }

                saveProjects();
                updateUIState(); // リスト表示の更新のために
                // alert('シーン内容を保存しました！'); // アラートは不要な場合も
            }


            // --- 描画機能 (廃止のためコメントアウト) ---
            // function setupDrawingCanvas() {
            //     const dpr = window.devicePixelRatio || 1;
            //     const rect = drawingCanvas.getBoundingClientRect();
            //     drawingCanvas.width = rect.width * dpr;
            //     drawingCanvas.height = rect.height * dpr;
            //     drawingCtx.scale(dpr, dpr);

            //     drawingCtx.lineCap = 'round';
            //     drawingCtx.lineJoin = 'round';
            // }
            // setupDrawingCanvas();

            // window.addEventListener('resize', () => {
            //     const selectedScene = findScene(currentSceneId);
            //     const oldDrawingData = selectedScene ? selectedScene.drawingData : null;
            //     setupDrawingCanvas();
            //     if (oldDrawingData) {
            //         const img = new Image();
            //         img.onload = () => {
            //             drawingCtx.drawImage(img, 0, 0, drawingCanvas.width / (window.devicePixelRatio || 1), drawingCanvas.height / (window.devicePixelRatio || 1));
            //         };
            //         img.src = oldDrawingData;
            //     }
            // });

            // drawingCanvas.addEventListener('mousedown', (e) => {
            //     if (!currentSceneId || !drawModeEnabled) return;
            //     isDrawing = true;
            //     [lastX, lastY] = [e.offsetX, e.offsetY];
            // });

            // drawingCanvas.addEventListener('mousemove', (e) => {
            //     if (!isDrawing) return;
            //     drawingCtx.strokeStyle = strokeColorInput.value;
            //     drawingCtx.lineWidth = strokeWidthInput.value;

            //     drawingCtx.beginPath();
            //     drawingCtx.moveTo(lastX, lastY);
            //     drawingCtx.lineTo(e.offsetX, e.offsetY);
            //     drawingCtx.stroke();
            //     [lastX, lastY] = [e.offsetX, e.offsetY];
            // });

            // drawingCanvas.addEventListener('mouseup', () => {
            //     if (!currentSceneId || !isDrawing) return;
            //     isDrawing = false;
            //     saveDrawingData();
            // });

            // drawingCanvas.addEventListener('mouseout', () => {
            //     if (!currentSceneId || !isDrawing) return;
            //     isDrawing = false;
            //     saveDrawingData();
            // });

            // // スマホでのタッチイベント対応
            // drawingCanvas.addEventListener('touchstart', (e) => {
            //     if (!currentSceneId || !drawModeEnabled) return;
            //     e.preventDefault();
            //     isDrawing = true;
            //     const touch = e.touches[0];
            //     const rect = drawingCanvas.getBoundingClientRect();
            //     [lastX, lastY] = [touch.clientX - rect.left, touch.clientY - rect.top];
            // }, { passive: false });

            // drawingCanvas.addEventListener('touchmove', (e) => {
            //     if (!isDrawing) return;
            //     e.preventDefault();
            //     const touch = e.touches[0];
            //     const rect = drawingCanvas.getBoundingClientRect();
            //     drawingCtx.strokeStyle = strokeColorInput.value;
            //     drawingCtx.lineWidth = strokeWidthInput.value;

            //     drawingCtx.beginPath();
            //     drawingCtx.moveTo(lastX, lastY);
            //     drawingCtx.lineTo(touch.clientX - rect.left, touch.clientY - rect.top);
            //     drawingCtx.stroke();
            //     [lastX, lastY] = [touch.clientX - rect.left, touch.clientY - rect.top];
            // }, { passive: false });

            // drawingCanvas.addEventListener('touchend', () => {
            //     if (!currentSceneId || !isDrawing) return;
            //     isDrawing = false;
            //     saveDrawingData();
            // });


            // function saveDrawingData() {
            //     if (!currentSceneId) return;
            //     const selectedScene = findScene(currentSceneId);
            //     if (selectedScene) {
            //         selectedScene.drawingData = drawingCanvas.toDataURL();
            //         saveProjects();
            //     }
            // }

            // function clearDrawing() {
            //     drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            //     if (currentSceneId) {
            //         const selectedScene = findScene(currentSceneId);
            //         if (selectedScene) {
            //             selectedScene.drawingData = null;
            //             saveProjects();
            //         }
            //     }
            // }
            // clearDrawingButton.addEventListener('click', clearDrawing);

            // toggleDrawModeButton.addEventListener('click', () => {
            //     drawModeEnabled = !drawModeEnabled;
            //     toggleDrawModeButton.textContent = drawModeEnabled ? '描画モード (ON)' : '描画モード (OFF)';
            //     drawingCanvas.style.cursor = drawModeEnabled ? 'crosshair' : 'default';
            // });
            // toggleDrawModeButton.textContent = '描画モード (ON)';


            // --- 画像アップロード機能 ---
            imageUploadInput.addEventListener('change', (event) => {
                if (!currentSceneId) {
                    alert('先にシーンを選択してください。');
                    imageUploadInput.value = '';
                    return;
                }
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        currentImageData = { dataUrl: e.target.result, name: file.name };
                        const img = document.createElement('img');
                        img.src = currentImageData.dataUrl;
                        imagePreview.innerHTML = '';
                        imagePreview.appendChild(img);

                        const selectedScene = findScene(currentSceneId);
                        if (selectedScene) {
                            selectedScene.imageData = currentImageData;
                            saveProjects();
                        }
                    };
                    reader.readAsDataURL(file);
                } else {
                    clearImagePreview();
                }
            });

            clearImageButton.addEventListener('click', () => {
                if (!currentSceneId) return;
                clearImagePreview();
                const selectedScene = findScene(currentSceneId);
                if (selectedScene) {
                    selectedScene.imageData = null;
                    saveProjects();
                }
            });

            function clearImagePreview() {
                imagePreview.innerHTML = '画像がここに表示されます';
                currentImageData = null;
                imageUploadInput.value = '';
            }


            // --- テーブル機能 ---
            createTableButton.addEventListener('click', () => {
                if (!currentSceneId) {
                    alert('先にシーンを選択してください。');
                    return;
                }
                const rows = parseInt(tableRowsInput.value) || 3;
                const cols = parseInt(tableColsInput.value) || 3;
                currentTableData = Array.from({ length: rows }, () => Array(cols).fill(''));
                renderTablePreview(currentTableData);
                saveTableData();
            });

            function renderTablePreview(tableData) {
                tablePreview.innerHTML = '';
                if (tableData.length === 0) {
                    tablePreview.style.display = 'none';
                    return;
                } else {
                    tablePreview.style.display = 'table';
                }

                tableData.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    row.forEach((cell, colIndex) => {
                        const td = document.createElement('td');
                        td.textContent = cell;
                        td.contentEditable = true;
                        td.dataset.rowIndex = rowIndex;
                        td.dataset.colIndex = colIndex;
                        td.addEventListener('input', handleTableCellInput);
                        tr.appendChild(td);
                    });
                    tablePreview.appendChild(tr);
                });
            }

            function handleTableCellInput(event) {
                const rowIndex = parseInt(event.target.dataset.rowIndex);
                const colIndex = parseInt(event.target.dataset.colIndex);
                if (!isNaN(rowIndex) && !isNaN(colIndex) && currentTableData[rowIndex]) {
                    currentTableData[rowIndex][colIndex] = event.target.textContent;
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = setTimeout(() => {
                        saveTableData();
                    }, AUTOSAVE_DELAY);
                }
            }

            function saveTableData() {
                if (!currentSceneId) return;
                const selectedScene = findScene(currentSceneId);
                if (selectedScene) {
                    selectedScene.tableData = currentTableData;
                    saveProjects();
                    console.log('Table data saved.');
                }
            }

            function clearTable() {
                currentTableData = [];
                tablePreview.innerHTML = '';
                tablePreview.style.display = 'none';
            }


            // --- タイムライン機能 ---
            function setupTimelineCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = timelineCanvas.getBoundingClientRect();
                timelineCanvas.width = rect.width * dpr;
                timelineCanvas.height = 100 * dpr;
                timelineCtx.scale(dpr, dpr);
            }
            setupTimelineCanvas();

            window.addEventListener('resize', setupTimelineCanvas);

            function drawTimeline() {
                timelineCtx.clearRect(0, 0, timelineCanvas.width / (window.devicePixelRatio || 1), timelineCanvas.height / (window.devicePixelRatio || 1));

                const selectedSequence = findSequence(currentSequenceId);
                if (!selectedSequence || selectedSequence.scenes.length === 0) {
                    timelineCtx.font = '14px Arial';
                    timelineCtx.fillStyle = '#666';
                    timelineCtx.textAlign = 'center';
                    timelineCtx.fillText('このシークエンスにはシーンがありません。', timelineCanvas.width / (2 * (window.devicePixelRatio || 1)), timelineCanvas.height / (2 * (window.devicePixelRatio || 1)));
                    return;
                }

                const scenes = selectedSequence.scenes;
                const canvasWidth = timelineCanvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = timelineCanvas.height / (window.devicePixelRatio || 1);
                const padding = 20; // 左右の余白
                const availableWidth = canvasWidth - (padding * 2);
                const sceneWidth = scenes.length > 0 ? Math.max(80, availableWidth / scenes.length) : 0; // 最小幅80px
                const startX = padding;
                const centerY = canvasHeight / 2;

                // タイムラインの幹線
                timelineCtx.strokeStyle = '#95a5a6'; /* 灰色の線 */
                timelineCtx.lineWidth = 2;
                timelineCtx.beginPath();
                timelineCtx.moveTo(startX, centerY);
                timelineCtx.lineTo(canvasWidth - padding, centerY);
                timelineCtx.stroke();

                scenes.forEach((scene, index) => {
                    const x = startX + (index * sceneWidth) + (sceneWidth / 2);

                    // シーンを表す縦線
                    timelineCtx.strokeStyle = '#3498db'; /* 青い線 */
                    timelineCtx.lineWidth = 2;
                    timelineCtx.beginPath();
                    timelineCtx.moveTo(x, centerY - 10);
                    timelineCtx.lineTo(x, centerY + 10);
                    timelineCtx.stroke();

                    // シーン名テキスト
                    timelineCtx.font = '12px Arial';
                    timelineCtx.textAlign = 'center';
                    timelineCtx.fillStyle = (scene.id === currentSceneId) ? '#e74c3c' : '#333'; /* 選択中のシーンを赤、他を黒 */

                    let sceneLabel = '';
                    if (scene.type === 'time') {
                        sceneLabel = scene.date || '日付不明';
                    } else if (scene.type === 'character') {
                        const project = findProject(currentProjectId);
                        const character = project ? project.characters.find(c => c.id === scene.characterId) : null;
                        sceneLabel = character ? character.name : scene.sceneCharacterName || '新規キャラ';
                    } else if (scene.type === 'story') {
                        sceneLabel = scene.chapterScene || 'シーン名';
                    }

                    // テキストを複数行に分割（簡易版、幅に収まらない場合）
                    const maxLen = 10; // 1行の最大文字数
                    let currentLine = '';
                    let yOffset = 0;
                    const words = sceneLabel.split(''); // 一文字ずつ分割して処理
                    for (let i = 0; i < words.length; i++) {
                        if (timelineCtx.measureText(currentLine + words[i]).width > sceneWidth - 10 && currentLine.length > 0) {
                            timelineCtx.fillText(currentLine, x, centerY + 20 + yOffset);
                            currentLine = words[i];
                            yOffset += 14;
                        } else {
                            currentLine += words[i];
                        }
                    }
                    if (currentLine.length > 0) {
                        timelineCtx.fillText(currentLine, x, centerY + 20 + yOffset);
                    }

                    // ドット表示
                    timelineCtx.beginPath();
                    timelineCtx.arc(x, centerY, 5, 0, Math.PI * 2);
                    timelineCtx.fillStyle = (scene.id === currentSceneId) ? '#e74c3c' : '#3498db';
                    timelineCtx.fill();
                });
            }

            toggleTimelineModeButton.addEventListener('click', drawTimeline); // 明示的にタイムラインを更新

            // タイムラインCanvasクリックでシーンを選択
            timelineCanvas.addEventListener('click', (e) => {
                const selectedSequence = findSequence(currentSequenceId);
                if (!selectedSequence || selectedSequence.scenes.length === 0) return;

                const rect = timelineCanvas.getBoundingClientRect();
                const clickX = (e.clientX - rect.left) * (window.devicePixelRatio || 1);
                const canvasWidth = timelineCanvas.width;
                const padding = 20 * (window.devicePixelRatio || 1);
                const availableWidth = canvasWidth - (padding * 2);
                const sceneWidth = selectedSequence.scenes.length > 0 ? Math.max(80 * (window.devicePixelRatio || 1), availableWidth / selectedSequence.scenes.length) : 0;
                const startX = padding;

                selectedSequence.scenes.forEach((scene, index) => {
                    const x = startX + (index * sceneWidth) + (sceneWidth / 2);
                    // クリック位置がシーンのドットの範囲内か判定（簡易的に横軸のみ）
                    if (clickX > x - (sceneWidth / 2) && clickX < x + (sceneWidth / 2)) {
                        selectScene(scene.id);
                        return;
                    }
                });
            });


            // --- ドラッグ＆ドロップ処理 ---
            let touchTimer = null; // 長押し判定用タイマー

            function handleDragStart(e) {
                draggedItem = this;
                dragType = this.dataset.type;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.id);
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                e.preventDefault();
                if (draggedItem && draggedItem !== this && draggedItem.dataset.type === this.dataset.type) {
                    e.dataTransfer.dropEffect = 'move';
                    const rect = this.getBoundingClientRect();
                    const offsetY = e.clientY - rect.top;
                    if (offsetY < rect.height / 2) {
                        this.classList.remove('drag-over-bottom');
                        this.classList.add('drag-over');
                    } else {
                        this.classList.remove('drag-over');
                        this.classList.add('drag-over-bottom');
                    }
                }
            }

            function handleDragLeave() {
                this.classList.remove('drag-over', 'drag-over-bottom');
            }

            function handleDrop(e) {
                e.preventDefault();
                this.classList.remove('drag-over', 'drag-over-bottom');

                if (draggedItem && draggedItem !== this && draggedItem.dataset.type === this.dataset.type) {
                    const fromId = draggedItem.dataset.id;
                    const toId = this.dataset.id;
                    const parentList = this.parentNode; // ドロップされた要素の親リスト

                    let list;
                    if (dragType === 'project') {
                        list = projects;
                    } else if (dragType === 'character') {
                        const selectedProject = findProject(currentProjectId);
                        list = selectedProject ? selectedProject.characters : [];
                    } else if (dragType === 'sequence') {
                        const selectedProject = findProject(currentProjectId);
                        list = selectedProject ? selectedProject.sequences : [];
                    } else if (dragType === 'scene') {
                        const selectedSequence = findSequence(currentSequenceId);
                        list = selectedSequence ? selectedSequence.scenes : [];
                    }

                    if (list.length > 0) {
                        const fromIndex = list.findIndex(item => item.id === fromId);
                        const toIndex = list.findIndex(item => item.id === toId);

                        if (fromIndex > -1 && toIndex > -1) {
                            const [movedItem] = list.splice(fromIndex, 1);
                            // 挿入位置を調整: toIndexより前に挿入する場合はそのまま、後ろに挿入する場合はtoIndexが1つずれるので調整
                            const insertIndex = (fromIndex < toIndex) ? toIndex : toIndex; // 修正: toIndexそのまま
                            
                            // ドロップ位置が要素の上半分か下半分かで挿入位置を微調整
                            const rect = this.getBoundingClientRect();
                            const offsetY = e.clientY - rect.top;
                            if (offsetY > rect.height / 2) { // 下半分なら次の要素の前に挿入
                                list.splice(toIndex + 1, 0, movedItem);
                            } else { // 上半分なら現在の要素の前に挿入
                                list.splice(toIndex, 0, movedItem);
                            }

                            saveProjects();
                            // 並べ替え後、選択状態を維持しつつUIを更新
                            if (dragType === 'project') {
                                // プロジェクトリストは再描画のみでOK、選択状態はselectProjectで設定される
                                renderProjectList();
                                // もし選択中のプロジェクトが動いたら、そのプロジェクトを選択し直す
                                if (currentProjectId === fromId) selectProject(fromId);
                            } else if (dragType === 'character') {
                                renderCharacterList();
                                if (currentCharacterId === fromId) selectCharacter(fromId);
                            } else if (dragType === 'sequence') {
                                renderSequenceList();
                                if (currentSequenceId === fromId) selectSequence(fromId);
                            } else if (dragType === 'scene') {
                                renderSceneList();
                                if (currentSceneId === fromId) selectScene(fromId);
                            } else {
                                updateUIState();
                            }

                            if (dragType === 'scene' && currentSequenceId) {
                                drawTimeline(); // シーンが並べ替えられたらタイムラインを再描画
                            }
                        }
                    }
                }
            }

            function handleDragEnd(e) {
                draggedItem.classList.remove('dragging');
                document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                    item.classList.remove('drag-over', 'drag-over-bottom');
                });
                draggedItem = null;
                dragType = null;
            }

            // --- タッチイベント（ドラッグ＆ドロップの代替） ---
            let longPressTarget = null;
            let initialTouchY = 0; // スクロール判定用

            function handleTouchStart(e) {
                if (e.touches.length !== 1) return; // 1本指のみ
                e.stopPropagation(); // 親要素へのイベント伝播を停止

                const listItem = this;
                longPressTarget = listItem;
                initialTouchY = e.touches[0].clientY;

                // 短いタップでの選択と、長押しでのドラッグを区別
                touchTimer = setTimeout(() => {
                    // 長押しと判定
                    listItem.classList.add('dragging'); // ドラッグ開始時のスタイル
                    draggedItem = listItem;
                    dragType = listItem.dataset.type;

                    // ドラッグ中のスタイルを適用するためにダミーのイベントデータをセット（機能はしないが、慣例として）
                    // e.dataTransfer はタッチイベントにはないので、ドラッグロジックを直接触る必要あり
                    // スマホでのドラッグは、要素の位置を直接操作する形に変わる
                    // ここでは、draggingクラスを追加して、移動はtouchmoveで行う
                }, 500); // 500ms長押しでドラッグ開始
            }

            function handleTouchMove(e) {
                if (!draggedItem) {
                    // ドラッグ開始していない場合、通常のスクロールと見なす
                    // ただし、preventDefalut()しないとリスト項目が勝手に動く場合がある
                    // e.preventDefault(); // ここでpreventすると常にスクロールが阻害される可能性がある
                    return;
                }
                e.preventDefault(); // ドラッグ中はスクロールを禁止

                const touch = e.touches[0];
                const currentY = touch.clientY;

                // draggedItemの位置を更新
                // draggedItem.style.position = 'absolute'; // 位置を絶対位置に
                // draggedItem.style.zIndex = 1001; // 最前面に
                // draggedItem.style.top = `${currentY - (draggedItem.offsetHeight / 2)}px`;
                // draggedItem.style.left = `${touch.clientX - (draggedItem.offsetWidth / 2)}px`;

                // ドロップ位置の判定とハイライト
                const listContainer = draggedItem.parentNode;
                const children = Array.from(listContainer.children);
                let overItem = null;

                for (const child of children) {
                    if (child === draggedItem || !child.classList.contains('list-item')) continue;

                    const rect = child.getBoundingClientRect();
                    if (currentY > rect.top && currentY < rect.bottom) {
                        overItem = child;
                        break;
                    }
                }

                children.forEach(child => child.classList.remove('drag-over', 'drag-over-bottom'));
                if (overItem) {
                    const rect = overItem.getBoundingClientRect();
                    const offsetY = currentY - rect.top;
                    if (offsetY < rect.height / 2) {
                        overItem.classList.add('drag-over');
                    } else {
                        overItem.classList.add('drag-over-bottom');
                    }
                }
            }

            function handleTouchEnd(e) {
                clearTimeout(touchTimer); // タイマーをクリア
                if (!draggedItem) { // 長押しでドラッグが開始されなかった場合
                    // 通常のタップとして処理 (要素選択)
                    if (longPressTarget) {
                        if (longPressTarget.dataset.type === 'project') selectProject(longPressTarget.dataset.id);
                        else if (longPressTarget.dataset.type === 'character') selectCharacter(longPressTarget.dataset.id);
                        else if (longPressTarget.dataset.type === 'sequence') selectSequence(longPressTarget.dataset.id);
                        else if (longPressTarget.dataset.type === 'scene') selectScene(longPressTarget.dataset.id);
                    }
                    longPressTarget = null;
                    return;
                }

                // ドロップ処理
                const listContainer = draggedItem.parentNode;
                const children = Array.from(listContainer.children);
                let dropTargetItem = null;

                const touch = e.changedTouches[0];
                const dropX = touch.clientX;
                const dropY = touch.clientY;

                for (const child of children) {
                    if (child === draggedItem || !child.classList.contains('list-item')) continue;

                    const rect = child.getBoundingClientRect();
                    if (dropY > rect.top && dropY < rect.bottom && dropX > rect.left && dropX < rect.right) {
                        dropTargetItem = child;
                        break;
                    }
                }

                if (dropTargetItem && draggedItem.dataset.type === dropTargetItem.dataset.type) {
                    const fromId = draggedItem.dataset.id;
                    const toId = dropTargetItem.dataset.id;

                    let list;
                    if (dragType === 'project') list = projects;
                    else if (dragType === 'character') list = findProject(currentProjectId).characters;
                    else if (dragType === 'sequence') list = findProject(currentProjectId).sequences;
                    else if (dragType === 'scene') list = findSequence(currentSequenceId).scenes;

                    const fromIndex = list.findIndex(item => item.id === fromId);
                    const toIndex = list.findIndex(item => item.id === toId);

                    if (fromIndex > -1 && toIndex > -1) {
                        const [movedItem] = list.splice(fromIndex, 1);
                        const rect = dropTargetItem.getBoundingClientRect();
                        const offsetY = dropY - rect.top;

                        if (offsetY > rect.height / 2) {
                            list.splice(toIndex + 1, 0, movedItem);
                        } else {
                            list.splice(toIndex, 0, movedItem);
                        }
                        saveProjects();
                        updateUIState(); // UI再描画
                    }
                }

                // ドラッグ終了時の後処理
                draggedItem.classList.remove('dragging');
                draggedItem.style.position = ''; // スタイルをリセット
                draggedItem.style.top = '';
                draggedItem.style.left = '';
                draggedItem.style.zIndex = '';

                document.querySelectorAll('.drag-over, .drag-over-bottom').forEach(item => {
                    item.classList.remove('drag-over', 'drag-over-bottom');
                });
                draggedItem = null;
                dragType = null;
                longPressTarget = null;
            }


            // --- 初期化 ---
            loadProjects(); // アプリ起動時に保存されたプロジェクトを読み込む

            // 最後に選択されていたプロジェクトなどを記憶・復元するロジック
            const lastSelectedProjectId = localStorage.getItem('lastSelectedProjectId');
            if (lastSelectedProjectId && projects.some(p => p.id === lastSelectedProjectId)) {
                selectProject(lastSelectedProjectId);
            } else if (projects.length > 0) {
                selectProject(projects[0].id); // 以前の選択がなければ最初の作品を選択
            } else {
                resetMainContentVisibility(); // プロジェクトが一つもない場合はUIを初期状態に
            }
            updateUIState(); // UIの初期状態を更新（重要）
        });
    </script>
</body>
</html>
